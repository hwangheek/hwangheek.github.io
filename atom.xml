<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ㅎㅎㅋ</title>
  
  <subtitle>ㅎㅎㅋ의 개인 연구실</subtitle>
  <link href="https://hwangheek.github.io/atom.xml" rel="self"/>
  
  <link href="https://hwangheek.github.io/"/>
  <updated>2022-07-23T14:39:52.366Z</updated>
  <id>https://hwangheek.github.io/</id>
  
  <author>
    <name>Hwanghee Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python으로 블랙리터만 (Black-Litterman) 모델 구현하기</title>
    <link href="https://hwangheek.github.io/2021/black-litterman/"/>
    <id>https://hwangheek.github.io/2021/black-litterman/</id>
    <published>2021-02-16T09:09:22.000Z</published>
    <updated>2022-07-23T14:39:52.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h1><p>금융 데이터를 이런저런 방식으로 분석해서 결과를 팀원들에게 공유하면, 반드시 나오는 중요한 질문이 하나 있습니다. 해당 결과를 어떻게 전략화 할 수 있냐는 겁니다. 분석 그 자체로써 의미있는 경우도 있지만, 결과적으로 (모델이 되었든 매니저가 되었든) 누군가는 포트폴리오 구성 및 운용 방식, 즉, 어떤 자산($X$)을 언제($t$), 얼마만큼($w$) 가지고 있어야 하는지에 대한 판단을 내려야 합니다.</p><p>포트폴리오 구성과 관련된 모델 중 가장 잘 알려진 이론은 <a href="https://www.investopedia.com/terms/m/meanvariance-analysis.asp">Mean-Variance Optimization Portfolio</a>일 것입니다. 해당 모델의 로직은 논리적이고 직관적이지만, 몇 가지 문제점들이 있습니다.</p><ol><li>입력 데이터의 작은 변화에도 도출되는 포트폴리오 구성비중이 크게 변합니다.</li><li>몇 개의 자산에 비중이 쏠리는 코너 솔루션이 나타나는 경우가 있습니다.</li><li>투자자가 가지고 있는 정보를 녹여낼 수 있는 방법 없습니다. 따라서, 시장에 대한 견해가 다른 매니저일지라도 (같은 hyperparameter를 가지고 있는 경우) 같은 MVO 포트폴리오를 얻게 됩니다.</li></ol><p>위 문제점들은 실제 운용을 할 때 걸림돌이 됩니다. (ex. 높은 turnover ratio, 규제위반, 모델에 들어가지 않은 추가적인 정보 반영 불가 등) 이러한 문제점들을 해결하기 위해, 골드만삭스의 Fischer Black과 Robert Litterman이 1990년에 개발하고 1992년에 발표한 포트폴리오 최적화 방법론이 Black-Litterman Model입니다.</p><p>본 포스팅은 Black-Litterman Portfolio Model의 전체적인 프로세스를 이해하고, Python으로 이를 구현해보는 과정을 정리해 놓은 글입니다. 내용에 문제나 개선점이 있는 경우, 피드백을 주시면 감사하겠습니다! 😀</p><span id="more"></span><h2 id="0-References"><a href="#0-References" class="headerlink" title="0. References"></a>0. References</h2><ul><li>Idzorek, T. “A step-by-step guide to the Black-Litterman model: Incorporating user-specified confidence levels.”, 2007<ul><li>모델을 이해하는데 가장 많이 참조한 자료로, 포스팅의 notation들은 해당 자료를 따라갔습니다.</li></ul></li><li>Stuart, J. “<a href="https://pythonforfinance.net/2020/11/27/black-litterman-portfolio-allocation-model-in-python/#more-17887">Black-Litterman Portfolio Allocation Model in Python</a>“, 2020<ul><li>Reverse Optimization Process를 이해하는데 큰 도움이 된 포스팅입니다.</li></ul></li><li>Tim Wilding. “<a href="https://quant.stackexchange.com/a/40943">Struggling with tau in Black-Litterman</a>“, 2018</li><li>Walters, Jay. “The Factor Tau in the Black-Litterman Model”, 2010<ul><li>$\tau$ 값을 이해하는데 도움이 됐었던 포스팅과 자료입니다.</li></ul></li><li>Satchell, S. and Scowcroft, A. “A Demystification of the Black-Litterman model: Managing Quantitative and Traditional Construction.”, 2000</li><li>Blamont, D. and Firoozy, N. “Asset Allocation Model.”, 2003</li><li>Olsson, Sebastian &amp; Trollsten, Viktor. “The Black-Litterman Asset Allocation Model”, 2018</li></ul><!-- - https://ko.wikipedia.org/wiki/블랙-리터만_모형 (Intro)- [Python PyPortfolioOpt 모듈](https://pyportfolioopt.readthedocs.io/en/latest/BlackLitterman.html)- http://egloos.zum.com/timebird/v/7469432 (Shortcoming)- https://junyoru.tistory.com/102 (Shortcoming)- https://hudsonthames.org/portfolio-optimisation-with-portfoliolab-mean-variance-optimisation/ (MVO)--><hr><h1 id="1-Top-down"><a href="#1-Top-down" class="headerlink" title="1. Top-down"></a>1. Top-down</h1><p>모델을 자세히 살펴보기에 앞서서, 모델에 사용되는 수식을 살펴보면 다음과 같습니다.</p><escape>\begin{align}  E[R]    &= [(\tau\Sigma)^{-1}+P^T\Omega^{-1}P]^{-1}[(\tau\Sigma)^{-1}\Pi+P^T\Omega^{-1}Q] \\  \hat{w} &= (\Sigma^{-1}E[R])/(1^T\Sigma^{-1}E[R])\end{align}</escape><escape>\begin{align*}  N       &\qquad\text{is the number of assets} \\  K       &\qquad\text{is the number of views} \\  E[R]    &\qquad\text{is the new (posterior) Combined Return Vector (N x 1 column vector)} \\  \tau    &\qquad\text{is a scalar} \\  \Sigma  &\qquad\text{is the covariance matrix of excess returns (N x N matrix)} \\  P       &\qquad\text{is a matrix that identifies the assets involved in the views} \\          &\qquad\text{(K x N matrix or 1 x N row vector in the special case of 1 view)} \\  \Omega  &\qquad\text{is a diagonal covariance matrix of error terms from the expressed views} \\          &\qquad\text{representing the uncertainty in each view (K x K matrix)} \\  \Pi     &\qquad\text{is the Implied Equilibrium Return Vector (N x 1 column vector)} \\  Q       &\qquad\text{is the View Vector (K x 1 column vector)} \\  \hat{w} &\qquad\text{is the new portfolio weight (N x 1 column vector) derived by the model} \\  \lambda &\qquad\text{is the risk aversion coefficient}\end{align*}</escape><p>수식이 엄청 복잡해 보이지만, 간단하게 요약하자면 수식(1)은 시장 데이터를 통해 도출된 “적당한” 수익률($\Pi$)과 투자자의 전망($Q$)을 “잘” 조합하여 새로운 기대수익률($E[R]$)을 만드는 과정입니다. 이렇게 도출된 기대수익률을 수식(2, unconstrained mean-variance maximization)와 같이 사용하여 새로운 포트폴리오 비중($\hat{w}$)을 구하는 것이, 모델의 최종 목표입니다.</p><p>이제 각각의 input들이 어떤 의미를 가지고 어떻게 설정해야 하는지, 소스코드가 진행되는 순서를 따라 예시와 함께 살펴봅시다.</p><hr><h1 id="2-Bottom-up-with-an-example"><a href="#2-Bottom-up-with-an-example" class="headerlink" title="2. Bottom-up (with an example)"></a>2. Bottom-up (with an example)</h1><h2 id="2-1-N-The-Number-of-Assets"><a href="#2-1-N-The-Number-of-Assets" class="headerlink" title="2.1. $N$ : The Number of Assets"></a>2.1. $N$ : The Number of Assets</h2><p>모델에 사용되는 자산의 개수입니다.</p><p>이번 포스팅에서는, 국내 주식 10개 섹터 수익률 데이터를 사용하기로 합니다. 섹터별 수익률 데이터(<code>monthly_excess_returns</code>)와 각 섹터별 비중(<code>w_mkt</code>) 데이터가 필요합니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monthly_excess_returns</span><br><span class="line">일자          에너지      소재    산업재  ...        IT  통신서비스  유틸리티</span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>  <span class="number">0.064542</span> -<span class="number">0.101358</span> -<span class="number">0.084858</span>  ...  <span class="number">0.079742</span>   -<span class="number">0.044158</span> -<span class="number">0.160058</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>  <span class="number">0.169433</span>  <span class="number">0.027033</span>  <span class="number">0.054333</span>  ...  <span class="number">0.044533</span>   -<span class="number">0.091467</span>  <span class="number">0.103133</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span> -<span class="number">0.190800</span> -<span class="number">0.175200</span> -<span class="number">0.187300</span>  ... -<span class="number">0.247900</span>   -<span class="number">0.275900</span>  <span class="number">0.035600</span></span><br><span class="line"><span class="number">2000</span>-05-<span class="number">31</span> -<span class="number">0.072333</span> -<span class="number">0.098433</span> -<span class="number">0.122233</span>  ... -<span class="number">0.050033</span>    <span class="number">0.138067</span> -<span class="number">0.072133</span></span><br><span class="line"><span class="number">2000</span>-06-<span class="number">30</span>  <span class="number">0.112958</span>  <span class="number">0.061258</span>  <span class="number">0.065258</span>  ...  <span class="number">0.143958</span>    <span class="number">0.045258</span>  <span class="number">0.124458</span></span><br><span class="line">              ...       ...       ...  ...       ...         ...       ...</span><br><span class="line"><span class="number">2020</span>-08-<span class="number">31</span>  <span class="number">0.043058</span>  <span class="number">0.144558</span>  <span class="number">0.016958</span>  ... -<span class="number">0.024642</span>    <span class="number">0.083358</span>  <span class="number">0.040158</span></span><br><span class="line"><span class="number">2020</span>-09-<span class="number">30</span> -<span class="number">0.072250</span> -<span class="number">0.049650</span> -<span class="number">0.002950</span>  ...  <span class="number">0.018750</span>   -<span class="number">0.025350</span> -<span class="number">0.001750</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">31</span> -<span class="number">0.036650</span> -<span class="number">0.001250</span> -<span class="number">0.004250</span>  ... -<span class="number">0.041450</span>   -<span class="number">0.077950</span> -<span class="number">0.000150</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">11</span>-<span class="number">30</span>  <span class="number">0.224950</span>  <span class="number">0.186950</span>  <span class="number">0.125250</span>  ...  <span class="number">0.147450</span>    <span class="number">0.104550</span>  <span class="number">0.067050</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">29</span>  <span class="number">0.034150</span>  <span class="number">0.036150</span>  <span class="number">0.031150</span>  ...  <span class="number">0.117950</span>   -<span class="number">0.002550</span>  <span class="number">0.149450</span></span><br><span class="line">[<span class="number">251</span> rows x <span class="number">10</span> columns]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monthly_excess_returns.columns</span><br><span class="line">Index([<span class="string">&#x27;에너지&#x27;</span>, <span class="string">&#x27;소재&#x27;</span>, <span class="string">&#x27;산업재&#x27;</span>, <span class="string">&#x27;경기소비재&#x27;</span>, <span class="string">&#x27;필수소비재&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;의료&#x27;</span>, <span class="string">&#x27;금융&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;통신서비스&#x27;</span>, <span class="string">&#x27;유틸리티&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_mkt</span><br><span class="line">에너지        <span class="number">0.0338</span></span><br><span class="line">소재          <span class="number">0.0912</span></span><br><span class="line">산업재        <span class="number">0.0924</span></span><br><span class="line">경기소비재    <span class="number">0.1315</span></span><br><span class="line">필수소비재    <span class="number">0.0452</span></span><br><span class="line">의료          <span class="number">0.1120</span></span><br><span class="line">금융          <span class="number">0.0609</span></span><br><span class="line">IT            <span class="number">0.4103</span></span><br><span class="line">통신서비스    <span class="number">0.0134</span></span><br><span class="line">유틸리티      <span class="number">0.0094</span></span><br><span class="line">Name: weights, dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>N = monthly_excess_returns.columns.size</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>N</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Sigma-Covariance-Matrix-of-Asset-Excess-Returns"><a href="#2-2-Sigma-Covariance-Matrix-of-Asset-Excess-Returns" class="headerlink" title="2.2. $\Sigma$ : Covariance Matrix of Asset Excess Returns"></a>2.2. $\Sigma$ : Covariance Matrix of Asset Excess Returns</h2><p>각 자산별 초과수익률의 공분산행렬입니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Sigma = monthly_excess_returns.cov()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Sigma</span><br><span class="line">            에너지    소재      산업재    ...  IT        통신서비스  유틸리티</span><br><span class="line">에너지      <span class="number">0.008452</span>  <span class="number">0.004698</span>  <span class="number">0.005392</span>  ...  <span class="number">0.003733</span>  <span class="number">0.002320</span>    <span class="number">0.002559</span></span><br><span class="line">소재        <span class="number">0.004698</span>  <span class="number">0.005819</span>  <span class="number">0.005411</span>  ...  <span class="number">0.003941</span>  <span class="number">0.002314</span>    <span class="number">0.002564</span></span><br><span class="line">산업재      <span class="number">0.005392</span>  <span class="number">0.005411</span>  <span class="number">0.007203</span>  ...  <span class="number">0.004600</span>  <span class="number">0.002450</span>    <span class="number">0.002828</span></span><br><span class="line">경기소비재  <span class="number">0.003492</span>  <span class="number">0.004154</span>  <span class="number">0.004939</span>  ...  <span class="number">0.004753</span>  <span class="number">0.002500</span>    <span class="number">0.002234</span></span><br><span class="line">필수소비재  <span class="number">0.002434</span>  <span class="number">0.002301</span>  <span class="number">0.002803</span>  ...  <span class="number">0.001972</span>  <span class="number">0.001537</span>    <span class="number">0.001942</span></span><br><span class="line">의료        <span class="number">0.003892</span>  <span class="number">0.003948</span>  <span class="number">0.004827</span>  ...  <span class="number">0.004101</span>  <span class="number">0.002414</span>    <span class="number">0.001920</span></span><br><span class="line">금융        <span class="number">0.004257</span>  <span class="number">0.004220</span>  <span class="number">0.004727</span>  ...  <span class="number">0.004055</span>  <span class="number">0.002356</span>    <span class="number">0.002712</span></span><br><span class="line">IT          <span class="number">0.003733</span>  <span class="number">0.003941</span>  <span class="number">0.004600</span>  ...  <span class="number">0.007571</span>  <span class="number">0.002820</span>    <span class="number">0.001931</span></span><br><span class="line">통신서비스  <span class="number">0.002320</span>  <span class="number">0.002314</span>  <span class="number">0.002450</span>  ...  <span class="number">0.002820</span>  <span class="number">0.004575</span>    <span class="number">0.002056</span></span><br><span class="line">유틸리티    <span class="number">0.002559</span>  <span class="number">0.002564</span>  <span class="number">0.002828</span>  ...  <span class="number">0.001931</span>  <span class="number">0.002056</span>    <span class="number">0.004902</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Reverse-Optimization-Process"><a href="#2-3-Reverse-Optimization-Process" class="headerlink" title="2.3. Reverse Optimization Process"></a>2.3. Reverse Optimization Process</h2><p>Mean-variance optimization process를 추상적으로 요약하자면, 자산의 수익률과 공분산 데이터를 사용하여 “최대 수익률, 최저 변동성”을 가지는 포트폴리오 비중을 구하는 과정이라고 할 수 있습니다. ($f: (\mu, \Sigma) \rightarrow w$) 이를 수식으로 표현한 것이 <em>quadratic risk utility function</em>이고, 최적화 문제를 아래와 같이 나타낼 수 있습니다.</p><escape>\begin{align}& \underset{w}{\operatorname{max}}\left(w^T\mu - \frac{1}{2}\lambda w^T\Sigma w\right) \\& \rightarrow \mu - \lambda\Sigma w = 0 \\& \rightarrow w = (\lambda\Sigma)^{-1}\mu\end{align}</escape><p>현재 시장에서 관찰할 수 있는 시가총액비중(market capitalization weight)이 위의 최적화 과정에서 도출 된 이상적인 비중이라고 가정 해봅시다. 자산 간 공분산행렬이 있는 경우, 식 (5)를 아래와 같이 변형하여, 각 자산의 “implied returns”를 역으로 구할 수 있습니다. ($g:(w_{mkt}, \Sigma) \rightarrow \mu_{implied}$).</p><escape>\begin{align}\mu_{implied} = \lambda \Sigma w_{mkt}\end{align}</escape><p>위와 같이, 시장에서 관측되는 자산비중을 기반으로 균형 수익률을 찾아내는 과정을 “Reverse Optimization Process”이라 하고, 이렇게 구해진 $\mu_{implied}$를 $\Pi$로 표기합니다.</p><h2 id="2-4-lambda-Risk-Aversion-Coefficient"><a href="#2-4-lambda-Risk-Aversion-Coefficient" class="headerlink" title="2.4. $\lambda$ : Risk Aversion Coefficient"></a>2.4. $\lambda$ : Risk Aversion Coefficient</h2><p>Reverse optimization process에서, 투자자가 낮은 변동성을 위하여 trade-off 할 수 있는 수익률 수준을 나타내는 상수로써, 일종의 scaling factor 역할을 합니다. 즉, $\lambda$가 클수록, implied returns ($\Pi$) 값이 커지게 됩니다. 값을 설정하는 방법은 자료에 따라 상이하지만, 얼추 다음과 같이 정리할 수 있습니다.</p><ul><li><strong>방법 1</strong> : <code>2.15</code> ~ <code>2.65</code> 사이의 값 (BLM 관련 연구자료들의 추천 결과 값)</li><li><strong>방법 2</strong> : $\frac{E(R_m)-R_f}{\sigma^2_m}$ (시가총액가중 포트폴리오의 평균 초과수익률 &#x2F; 분산)</li></ul><p>본 포스팅에서는 두 번째 방법을 사용하도록 하겠습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>expected_portfolio_excess_return = monthly_excess_returns.mean().multiply(w_mkt).<span class="built_in">sum</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>portfolio_variance = w_mkt.dot(Sigma).dot(w_mkt)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lambd = expected_portfolio_excess_return / portfolio_variance</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lambd</span><br><span class="line"><span class="number">1.4956952957871978</span></span><br></pre></td></tr></table></figure><h2 id="2-5-Pi-Implied-Excess-Equilibrium-Return-Vector"><a href="#2-5-Pi-Implied-Excess-Equilibrium-Return-Vector" class="headerlink" title="2.5. $\Pi$ : Implied Excess Equilibrium Return Vector"></a>2.5. $\Pi$ : Implied Excess Equilibrium Return Vector</h2><p>위에서 계산한 $\lambda$, $\Sigma$, $w_{mkt}$를 사용하여, 현 시장에서 관측되는 시가총액비중 기반 equilibrium return vector를 다음과 같이 계산합니다.</p><escape>\begin{equation}  \Pi = \lambda \Sigma w_{mkt}\end{equation}</escape><escape>\begin{align*}  \lambda &\qquad\text{is the risk aversion coefficient} \\  \Sigma  &\qquad\text{is the covariance matrix of excess returns (N x N matrix)} \\  w_{mkt} &\qquad\text{is the market capitalization weight (N x 1 column vector) of the assets}\end{align*}</escape><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pi = lambd * Sigma.dot(w_mkt)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pi</span><br><span class="line">에너지        <span class="number">0.006078</span></span><br><span class="line">소재          <span class="number">0.006298</span></span><br><span class="line">산업재        <span class="number">0.007318</span></span><br><span class="line">경기소비재    <span class="number">0.006756</span></span><br><span class="line">필수소비재    <span class="number">0.003517</span></span><br><span class="line">의료          <span class="number">0.006820</span></span><br><span class="line">금융          <span class="number">0.006116</span></span><br><span class="line">IT            <span class="number">0.008216</span></span><br><span class="line">통신서비스    <span class="number">0.003837</span></span><br><span class="line">유틸리티      <span class="number">0.003304</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h2 id="2-6-K-The-Number-of-Views"><a href="#2-6-K-The-Number-of-Views" class="headerlink" title="2.6. $K$ : The Number of Views"></a>2.6. $K$ : The Number of Views</h2><p>Black-Litterman Model에서는 투자자가 가지고 있는 정보를 “View”라고 정의합니다. (한글로 해석하면 ‘전망’ 정도 될 것 같습니다.)</p><p>이번 예시에서는, 투자자에게 다음과 같은 세 가지의 view가 있다고 가정해봅시다.</p><ul><li><strong>View 1</strong> : IT 섹터의 초과 수익률이 2%가 될 것이다. (Confidence level &#x3D; 75%)</li><li><strong>View 2</strong> : 통신서비스 섹터의 수익률이 유틸리티 섹터의 수익률보다 3% 높을 것이다. (Confidence level &#x3D; 25%)</li><li><strong>View 3</strong> : 에너지 섹터의 수익률이 경기소비재, 필수소비재 섹터 수익률보다 1% 높을 것이다. (Confidence level &#x3D; 50%)</li></ul><p>여기서 view 1은 “absolute view”, view 2~3은 “relative view”라고 합니다. Relative view는 outperforming 하는 자산(통신서비스, 에너지)과 underperforming 하는 자산(유틸리티, 경기소비재, 필수소비재)을 포함합니다. 예시의 view 3에서와 같이, outperforming 하는 자산의 수와 underperforming하는 자산의 수가 반드시 동일해야 할 필요는 없습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>K = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="2-7-Q-View-Vector"><a href="#2-7-Q-View-Vector" class="headerlink" title="2.7. $Q$ : View Vector"></a>2.7. $Q$ : View Vector</h2><p>각 view들의 예상 수치(예상 절대&#x2F;상대수익률)를 포함하는, $K$x$1$ column matrix 입니다. 이번 예시에서의 view vector는 다음과 같습니다.</p><escape>\begin{equation*}  K =  \begin{bmatrix}    0.02 \\    0.03 \\    0.01 \\  \end{bmatrix}\end{equation*}</escape><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q = np.array([<span class="number">0.02</span>, <span class="number">0.03</span>, <span class="number">0.01</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> Q.shape == (K,)</span><br></pre></td></tr></table></figure><h2 id="2-8-P-Picking-Matrix"><a href="#2-8-P-Picking-Matrix" class="headerlink" title="2.8. $P$ : Picking Matrix"></a>2.8. $P$ : Picking Matrix</h2><p>View에 포함되는 자산들을 명시해주는 행렬입니다. 이번 예시의 경우, 총 3개의 view와 10개의 자산이 있으므로, $P$는 아래와 같은 3x10 행렬이 됩니다.</p><escape>\begin{equation*}  P =  \begin{bmatrix}    0 & 0 & 0 &    0 &    0 & 0 & 0 & 1 & 0 &  0 \\    0 & 0 & 0 &    0 &    0 & 0 & 0 & 0 & 1 & -1 \\    1 & 0 & 0 & -0.5 & -0.5 & 0 & 0 & 0 & 0 &  0 \\  \end{bmatrix}\end{equation*}</escape><p>첫 번째 행은 첫 번째 view를 나타낸 행으로, 데이터 순서 상 8번 째 자산인 IT섹터를 1로 표시합니다. Absolute view의 경우에는 이와 같이 하나의 column만 1이 되는 row의 형태로 나타납니다.</p><p>두 번째와 세 번째 행은, 각각 두 번째와 세 번째 view를 나타냅니다. Outperforming 할 것으로 예상되는 자산은 양수로, underperforming 할 것으로 예상되는 자산은 음수로 표시하여, row의 총 합이 0이 되도록 맞춰줍니다.<br>View 3와 같이 다수의 자산이 명시가 되어야 하는 경우, outperforming 하는 자산의 합이 1, underperforming 하는 자산의 합이 -1, row의 총 합이 0이 되도록 값을 분배합니다.</p><p>위의 행렬 $P$에서 view 3는 underperforming 할 것으로 예상되는 두 자산(경기소비재, 필수소비재)에 대해 동일한 비중으로 값을 설정했습니다. 이 경우, 상대적으로 market cap이 작은 자산의 최종 포트폴리오 비중의 값이 더 많이 변하는 문제가 발생할 수 있습니다. 이러한 문제를 해결하기 위해, $P$ 행렬에서의 비중을 market cap과 동일(혹은 유사)하게 설정하는 방법이 있습니다.</p><p>이번 예시에서 경기소비재의 market cap(0.1315)은 필수소비재의 market cap(0.0452)의 약 3배 정도 됩니다. 이를 고려하여 $P$의 값을 아래와 같이 조정할 수 있습니다.</p><escape>\begin{equation*}  P =  \begin{bmatrix}    0 & 0 & 0 &     0 &     0 & 0 & 0 & 1 & 0 &  0 \\    0 & 0 & 0 &     0 &     0 & 0 & 0 & 0 & 1 & -1 \\    1 & 0 & 0 & -0.75 & -0.25 & 0 & 0 & 0 & 0 &  0 \\  \end{bmatrix}\end{equation*}</escape><p>위에서 정의 된 $P$의 k번째 행(1xN row vector)을 $p_k$로 표기합시다. 이를 사용해서, 각 view를 기반으로 구성된 portfolio의 variance를 $p_k \Sigma p_k^T$로 구할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>P = np.array([</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,    <span class="number">0</span>,    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,    <span class="number">0</span>,    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">.75</span>, -<span class="number">.25</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> P.shape == (K, N)</span><br></pre></td></tr></table></figure><h2 id="2-9-tau-Scalar-“Tuning”-Constant"><a href="#2-9-tau-Scalar-“Tuning”-Constant" class="headerlink" title="2.9. $\tau$ : Scalar “Tuning” Constant"></a>2.9. $\tau$ : Scalar “Tuning” Constant</h2><p>Prior estimate of returns($\Pi$)에 대한 불확실 정도를 나타내는 수치입니다. $\tau$ 값이 작을수록, 모델에 의해 계산되는 combined return vector($E[R]$)가 implied equilibrium return($\Pi$)에 가까워지게 됩니다.</p><p>아쉽게도, $\tau$ 값을 정하는 명확한 가이드가 없습니다. 아래는 $\tau$값으로 제시된 다양한 후보들입니다.</p><ul><li><em>0.01과 0.05 사이의 값</em>으로 최초 설정한 뒤, tracking error를 줄이는 방향으로 조정</li><li><em>1</em>로 설정 (Satchell and Scowcroft, 2000)</li><li>*1&#x2F;(number of observation)*으로 설정 (Blamont and Firoozye, 2003)</li></ul><p>좋게 보면 flexible하다고 볼 수 있지만, 일관된 기준이 없다는 점은 모델을 이해하기 어렵고 애매모호하게 만듭니다.</p><p>이러한 모호함을 없애기 위하여, 이후 소개드릴 <strong>$\Omega$의 값에 $\tau$를 factor-out 시킬 수 있도록 값을 설정하는 방법</strong>이 있습니다. (Idzorek, 2007) 이번 포스팅에서는 해당 방법을 사용하겠습니다. 따라서, $\tau$에 0이 아닌 어떠한 값을 넣어도, 최종 결과($E[R]$)에는 영향을 미치지 않게 됩니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tau = <span class="number">1</span>  <span class="comment"># 0이 아닌 임의의 값</span></span><br></pre></td></tr></table></figure><h2 id="2-10-Omega-Uncertainty-Matrix-of-Views"><a href="#2-10-Omega-Uncertainty-Matrix-of-Views" class="headerlink" title="2.10. $\Omega$ : Uncertainty Matrix of Views"></a>2.10. $\Omega$ : Uncertainty Matrix of Views</h2><p>개별 view들의 불확실 정도를 나타내는 대각행렬입니다. 행렬의 원소인 $\omega_k$가 0에 가까울 수록 view k의 confidence가 100%에 가깝다는 것을 의미하고, $\omega_k$가 클수록 해당 view의 불확실성이 높음을 의미합니다.</p><escape>\begin{equation}  \Omega =  \begin{bmatrix}    \omega_1 & 0 & 0 \\    0 & \ddots & 0 \\    0 & 0 & \omega_k \\  \end{bmatrix}\end{equation}</escape><p>사용자가 개별 view에 대한 confidence 정보를 가지고 있는 경우, $\Omega$의 값을 직접 입력할 수도 있지만, 이번 포스팅에서는 개별 view를 기반으로 생성된 portfolio의 variance를 이용하는 방법을 사용하겠습니다. <em>(Confidence level of views를 기반으로 $\Omega$를 정하는 방법은 본 포스팅의 이후 챕터에서 확인하실 수 있습니다.)</em></p><escape>\begin{equation*}  \Omega = diag(P(\tau\Sigma)P^T) =  \begin{bmatrix}    (p_1 \Sigma p_1^T)*\tau & 0 & 0 \\    0 & \ddots & 0 \\    0 & 0 & (p_K \Sigma p_K^T)*\tau \\  \end{bmatrix}\end{equation*}</escape><p>위와 같이 $\Omega$를 설정할 경우, $\tau$ 값이 변해도 $E[R]$ 값이 변하지 않습니다. $\tau$와 $\Omega$값이 데이터를 기반으로 계산이 되므로, 매니저는 view와 관련된 input만 신경을 쓰면 됩니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Omega = tau*P.dot(Sigma).dot(P.T) * np.eye(K)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Omega</span><br><span class="line">array([[ <span class="number">0.0075706</span> ,  <span class="number">0.</span>        , -<span class="number">0.</span>        ],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">0.00536469</span>, -<span class="number">0.</span>        ],</span><br><span class="line">       [-<span class="number">0.</span>        , -<span class="number">0.</span>        ,  <span class="number">0.00634097</span>]])</span><br></pre></td></tr></table></figure><p>단, 이번 포스팅에서와 같이 <strong>데이터를 기반으로 $\tau$와 $\Omega$를 정하는 방법은 모델을 사용하는 여러가지 방법 중 하나</strong>임을 인지할 필요가 있습니다. 필요시, 해당 값들을 변경해가며 최적의 모델 결과를 도출하면 되겠습니다.</p><hr><h1 id="3-Run-It-but-without-confidence-level-of-views"><a href="#3-Run-It-but-without-confidence-level-of-views" class="headerlink" title="3. Run It (but without confidence level of views)"></a>3. Run It (but without confidence level of views)</h1><p>모델에 필요한 데이터들이 준비됐습니다. 이를 기반으로 $E[R]$과 $\hat{w}$를 다음과 같이 구할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ER = Pi + tau*Sigma.dot(P.T).dot(inv(P.dot(tau*Sigma).dot(P.T) + Omega).dot(Q - P.dot(Pi)))</span><br><span class="line"><span class="meta">... </span><span class="comment"># 수식(1)을 다르게 표현한 수식으로, 동일한 결과값을 계산합니다</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ER</span><br><span class="line">에너지       <span class="number">0.012334</span></span><br><span class="line">소재         <span class="number">0.009002</span></span><br><span class="line">산업재       <span class="number">0.010075</span></span><br><span class="line">경기소비재   <span class="number">0.009281</span></span><br><span class="line">필수소비재   <span class="number">0.003478</span></span><br><span class="line">의료         <span class="number">0.010962</span></span><br><span class="line">금융         <span class="number">0.008156</span></span><br><span class="line">IT           <span class="number">0.015176</span></span><br><span class="line">통신서비스   <span class="number">0.012539</span></span><br><span class="line">유틸리티    -<span class="number">0.002864</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat = inv(Sigma).dot(ER)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat = pd.Series(w_hat / w_hat.<span class="built_in">sum</span>(), index=R.columns)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat</span><br><span class="line">에너지       <span class="number">0.430068</span></span><br><span class="line">소재         <span class="number">0.063951</span></span><br><span class="line">산업재       <span class="number">0.064792</span></span><br><span class="line">경기소비재  -<span class="number">0.212565</span></span><br><span class="line">필수소비재  -<span class="number">0.069897</span></span><br><span class="line">의료         <span class="number">0.078536</span></span><br><span class="line">금융         <span class="number">0.042704</span></span><br><span class="line">IT           <span class="number">0.586425</span></span><br><span class="line">통신서비스   <span class="number">1.284972</span></span><br><span class="line">유틸리티    -<span class="number">1.268985</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat - w_mkt</span><br><span class="line">에너지       <span class="number">0.396268</span></span><br><span class="line">소재        -<span class="number">0.027249</span></span><br><span class="line">산업재      -<span class="number">0.027608</span></span><br><span class="line">경기소비재  -<span class="number">0.344065</span></span><br><span class="line">필수소비재  -<span class="number">0.115097</span></span><br><span class="line">의료        -<span class="number">0.033464</span></span><br><span class="line">금융        -<span class="number">0.018196</span></span><br><span class="line">IT           <span class="number">0.176125</span></span><br><span class="line">통신서비스   <span class="number">1.271572</span></span><br><span class="line">유틸리티    -<span class="number">1.278385</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>Outperform 할 것으로 예상되는 섹터들(IT, 통신서비스, 에너지)의 비중은 상향 조정되었고, underperform 할 것으로 예상되는 섹터들(유틸리티, 경기소비재, 필수소비재)의 비중은 하향 조정되었습니다. View에 포함된 자산 뿐만 아니라, 포함되지 않은 자산까지 비중이 전체적으로 조정된 것을 확인할 수 있습니다.</p><p>조정된 비중을 살펴보면 설명이 애매한 부분들이 있습니다. 그 중 하나가, 상대적으로 confidence level이 높은 view 1(IT &#x3D; 2%)에 비해 confidence level이 낮은 view 2(통신서비스 - 유틸리티 &#x3D; 3%)의 비중이 과도하게 조정이 됐다는 점입니다. 앞선 프로세스를 잘 생각해보면, <strong>아직 각 view의 confidence level을 모델에 반영하지 않았고</strong>, 이로 인해 비중의 조정이 $Q$의 값에 지나치게 영향을 많이 받았을 가능성이 있습니다.</p><hr><h1 id="4-Considering-Confidence-Level-of-Views"><a href="#4-Considering-Confidence-Level-of-Views" class="headerlink" title="4. Considering Confidence Level of Views"></a>4. Considering Confidence Level of Views</h1><p>본 포스팅에서 사용하는 view들을 다시 한번 확인해봅시다.</p><ul><li><strong>View 1</strong> : IT 섹터의 초과 수익률이 2%가 될 것이다. <strong>(Confidence level &#x3D; 75%)</strong></li><li><strong>View 2</strong> : 통신서비스 섹터의 수익률이 유틸리티 섹터의 수익률보다 3% 높을 것이다. <strong>(Confidence level &#x3D; 25%)</strong></li><li><strong>View 3</strong> : 에너지 섹터의 수익률이 경기소비재, 필수소비재 섹터 수익률보다 1% 높을 것이다. <strong>(Confidence level &#x3D; 50%)</strong></li></ul><p>각 view의 confidence level인 75%, 25%, 50%의 값을 모델에 어떻게 녹여낼 수 있을까요? $\Omega$ (uncertainty matrix of views)와 연관이 있는 건 확실해 보이는데, 그렇다고 위의 값($0.75$, $0.25$, $0.50$)을 그대로 행렬에 넣을 수는 없어 보입니다. $\Omega$ 값을 조정해보면서 결과를 살펴봐야 하는데, 이러한 과정을 체계화하여 정리한 하나의 방법을 소개해드리겠습니다. (Idzorek, 2007)</p><ol><li><p>계산 과정에 필요한 모듈을 import하고 새로 계산될 $\Omega$의 결과를 담아둘 수 있는 행렬을 선언합니다.</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>implied_Omega = np.zeros((K, K))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">0</span>  <span class="comment"># 본 포스팅을 line-by-line 실행하는 경우를 위하여 임시로 선언하는 iterator로,</span></span><br><span class="line"><span class="meta">... </span>       <span class="comment"># 실제 구현에서는 사용되지 않습니다</span></span><br></pre></td></tr></table></figure></li><li><p>각 view의 confidence level들로 이루어진 행렬 $C$를 정의합니다.</p> <escape> \begin{equation}   C =   \begin{bmatrix}     0.75 \\     0.25 \\     0.50 \\   \end{bmatrix} \end{equation} </escape> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = np.array([<span class="number">0.75</span>, <span class="number">0.25</span>, <span class="number">0.50</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> C.shape == (K,)</span><br></pre></td></tr></table></figure></li></ol><p>이제 각 view를 iterator <code>k</code>를 사용하여 하나씩 iterate하면서 아래의 과정을 진행합니다.</p><ol start="3"><li><p><strong>View k가 모델의 유일한 view이고 100% 확실다는 가정하에</strong>, $E[R]$ 값과 $w$ 값을 계산합니다. (이 때 계산되는 결과값을 각각 $E[R_{\text{k,100%}}]$ , $w_{\text{k,100%}}$ 라고 표기합니다.)</p><p> View k가 100% 확실한 경우, (1)~(2)의 수식은 아래와 같이 정리할 수 있습니다.</p> <escape> \begin{align}   E[R_{\text{k,100%}}]  &= \Pi + \tau\Sigma P_{k}^T (P_k \tau\Sigma P_{k}^T)^{-1}\\   w_{\text{k,100%}}     &= (\Sigma^{-1}E[R_{\text{k,100%}}])/(1^T\Sigma^{-1}E[R_{\text{k,100%}}]) \end{align} </escape> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 기존 ER을 구하는 수식에서 P를 P[None, k]로, Q를 Q[None, k]로 대체하고,</span></span><br><span class="line"><span class="comment"># Omega를 생략한 수식입니다.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ER_k_100 = Pi + tau*Sigma.dot(P[<span class="literal">None</span>, k].T).dot(inv(P[<span class="literal">None</span>, k].dot(tau * Sigma).dot(P[<span class="literal">None</span>, k].T)).dot(Q[<span class="literal">None</span>, k] - P[<span class="literal">None</span>, k].dot(Pi)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_k_100 = inv(Sigma).dot(ER_k_100)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_k_100 = pd.Series(w_k_100 / w_k_100.<span class="built_in">sum</span>(), index=R.columns)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_k_100</span><br><span class="line">에너지       <span class="number">0.016562</span></span><br><span class="line">소재         <span class="number">0.044689</span></span><br><span class="line">산업재       <span class="number">0.045277</span></span><br><span class="line">경기소비재   <span class="number">0.064436</span></span><br><span class="line">필수소비재   <span class="number">0.022148</span></span><br><span class="line">의료         <span class="number">0.054881</span></span><br><span class="line">금융         <span class="number">0.029842</span></span><br><span class="line">IT           <span class="number">0.710993</span></span><br><span class="line">통신서비스   <span class="number">0.006566</span></span><br><span class="line">유틸리티     <span class="number">0.004606</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></li><li><p><strong>View k가 모델의 유일한 view라는 가정하에</strong>, 주어진 confidence level을 반영되었을 경우의 $w$를 추론합니다. (이 때 추론되는 값을 $w_{\text{k,%}}$ 라고 표기합니다.)</p><p> View k의 confidence level이 100%인 경우 포트폴리오 비중이 $w_{\text{k,100%}}$이고, confidence level이 0%인 경우 포트폴리오 비중이 $w_{mkt}$입니다. 따라서, confidence level이 $C_k$인 경우 포트폴리오 비중을 다음과 같이 추론할 수 있습니다.</p> <escape> \begin{align}   w_{\text{k,%}} = w_{mkt} + (w_{\text{k,100%}} - w_{mkt}) * C_k \end{align} </escape> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_k_implied = w_mkt + (w_k_100 - w_mkt) * C[k]</span><br></pre></td></tr></table></figure></li><li><p><strong>View k가 모델의 유일한 view라는 가정하에</strong>, view k의 confidence interval $\omega_k$ (<code>omega_k</code>, the k-th diagonal element of $\Omega$) 값을 조절해보면서, confidence interval이 반영된 포트폴리오의 결과가 $w_{\text{k,%}}$에 가깝도록 하는 $\omega_k$ 값을 찾습니다.</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">omega_k</span>):</span><br><span class="line">    <span class="comment"># 기존 ER을 구하는 수식에서 P를 P[None, k]로, Q를 Q[None, k]로 대체한 수식입니다.</span></span><br><span class="line">    ER_k = Pi + tau * Sigma.dot(P[<span class="literal">None</span>, k].T).dot(inv(P[<span class="literal">None</span>, k].dot(tau * Sigma).dot(P[<span class="literal">None</span>, k].T) + omega_k).dot(Q[<span class="literal">None</span>, k] - P[<span class="literal">None</span>, k].dot(Pi)))</span><br><span class="line">    </span><br><span class="line">    w_k = inv(Sigma).dot(ER_k)</span><br><span class="line">    w_k = pd.Series(w_k / w_k.<span class="built_in">sum</span>(), index=R.columns)</span><br><span class="line">    </span><br><span class="line">    diff = w_k_implied - w_k</span><br><span class="line">    <span class="keyword">return</span> diff.T.dot(diff)</span><br><span class="line"></span><br><span class="line">implied_Omega[k][k] = optimize.minimize_scalar(</span><br><span class="line">    fun=fun,</span><br><span class="line">    bounds=(<span class="number">1e-8</span>, <span class="number">1e+12</span>),</span><br><span class="line">    method=<span class="string">&#x27;bounded&#x27;</span>,</span><br><span class="line">).x</span><br></pre></td></tr></table></figure></li><li><p>위 3~5번 과정을 모든 k에 대해 iterate하여 <code>implied_Omega</code>를 구합니다.</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>implied_Omega</span><br><span class="line">array([[<span class="number">0.00514838</span>, <span class="number">0.</span>        , <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">0.01609381</span>, <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.006342</span>  ]])</span><br></pre></td></tr></table></figure></li></ol><p>이렇게 계산된 <code>implied_Omega</code> 값을 사용하여 전체적인 모델 프로세스를 다시 진행하면, 다음과 같은 결과를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ER_with_CL = Pi + tau * Sigma.dot(P.T).dot(inv(P.dot(tau * Sigma).dot(P.T) + implied_Omega).dot(Q - P.dot(Pi)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat_with_CL = inv(Sigma).dot(ER_with_CL)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat_with_CL = pd.Series(w_hat_with_CL / w_hat_with_CL.<span class="built_in">sum</span>(), index=R.columns)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w_hat_with_CL</span><br><span class="line">에너지       <span class="number">0.377316</span></span><br><span class="line">소재         <span class="number">0.058063</span></span><br><span class="line">산업재       <span class="number">0.058827</span></span><br><span class="line">경기소비재  -<span class="number">0.183128</span></span><br><span class="line">필수소비재  -<span class="number">0.060173</span></span><br><span class="line">의료         <span class="number">0.071305</span></span><br><span class="line">금융         <span class="number">0.038772</span></span><br><span class="line">IT           <span class="number">0.624501</span></span><br><span class="line">통신서비스   <span class="number">0.583587</span></span><br><span class="line">유틸리티    -<span class="number">0.569071</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><img src="/images/2021-02-black-litterman-result.png" class="Async Everywhere" title="BLMResult"><p>Confidence level이 고려되지 않은 결과보다, 조금 더 설득력 있는 형태의 포트폴리오가 구성되었습니다.</p><hr><h1 id="5-Dealing-with-Constraints"><a href="#5-Dealing-with-Constraints" class="headerlink" title="5. Dealing with Constraints"></a>5. Dealing with Constraints</h1><p>모델의 전체적인 프로세스를 진행하는 과정에서, 포트폴리오의 비중을 구하기 위하여 크게 다음의 두 가지 스텝을 밟았습니다.</p><ul><li>Black-Litterman 모델을 통해 자산별 기대수익률($E[R]$)을 계산하고,</li><li>해당 기대수익률을 기반으로 mean-variance optimization을 적용하여 새로운 비중($\hat{w}$)을 계산했습니다.</li></ul><p>본 포스트에서는 제약조건이 없는 mean-variance optimization(unconstrained maximization optimization process)을 가정하였습니다. ($\hat{w} &#x3D; (\Sigma^{-1}E[R])&#x2F;(1^T\Sigma^{-1}E[R])$) 만약 포트폴리오 구성 시 제약조건(보유비중, 리스크, 베타, long-only portfolio 등)이 있는 경우, 위의 (2)번 프로세스에 제약조건을 더해 mean-variance optimization을 진행하면 되겠습니다. (이 경우 closed-form solution을 구하는 방법보다는, confidence level을 반영하는 과정에서 <code>scipy.optimize</code>를 사용한 것과 비슷하게 numerical solution을 찾는게 효과적일 것으로 판단됩니다.)</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-Introduction&quot;&gt;&lt;a href=&quot;#0-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0. Introduction&quot;&gt;&lt;/a&gt;0. Introduction&lt;/h1&gt;&lt;p&gt;금융 데이터를 이런저런 방식으로 분석해서 결과를 팀원들에게 공유하면, 반드시 나오는 중요한 질문이 하나 있습니다. 해당 결과를 어떻게 전략화 할 수 있냐는 겁니다. 분석 그 자체로써 의미있는 경우도 있지만, 결과적으로 (모델이 되었든 매니저가 되었든) 누군가는 포트폴리오 구성 및 운용 방식, 즉, 어떤 자산($X$)을 언제($t$), 얼마만큼($w$) 가지고 있어야 하는지에 대한 판단을 내려야 합니다.&lt;/p&gt;
&lt;p&gt;포트폴리오 구성과 관련된 모델 중 가장 잘 알려진 이론은 &lt;a href=&quot;https://www.investopedia.com/terms/m/meanvariance-analysis.asp&quot;&gt;Mean-Variance Optimization Portfolio&lt;/a&gt;일 것입니다. 해당 모델의 로직은 논리적이고 직관적이지만, 몇 가지 문제점들이 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;입력 데이터의 작은 변화에도 도출되는 포트폴리오 구성비중이 크게 변합니다.&lt;/li&gt;
&lt;li&gt;몇 개의 자산에 비중이 쏠리는 코너 솔루션이 나타나는 경우가 있습니다.&lt;/li&gt;
&lt;li&gt;투자자가 가지고 있는 정보를 녹여낼 수 있는 방법 없습니다. 따라서, 시장에 대한 견해가 다른 매니저일지라도 (같은 hyperparameter를 가지고 있는 경우) 같은 MVO 포트폴리오를 얻게 됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 문제점들은 실제 운용을 할 때 걸림돌이 됩니다. (ex. 높은 turnover ratio, 규제위반, 모델에 들어가지 않은 추가적인 정보 반영 불가 등) 이러한 문제점들을 해결하기 위해, 골드만삭스의 Fischer Black과 Robert Litterman이 1990년에 개발하고 1992년에 발표한 포트폴리오 최적화 방법론이 Black-Litterman Model입니다.&lt;/p&gt;
&lt;p&gt;본 포스팅은 Black-Litterman Portfolio Model의 전체적인 프로세스를 이해하고, Python으로 이를 구현해보는 과정을 정리해 놓은 글입니다. 내용에 문제나 개선점이 있는 경우, 피드백을 주시면 감사하겠습니다! 😀&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://hwangheek.github.io/tags/Python/"/>
    
    <category term="Portfolio Theory" scheme="https://hwangheek.github.io/tags/Portfolio-Theory/"/>
    
    <category term="Black-Litterman" scheme="https://hwangheek.github.io/tags/Black-Litterman/"/>
    
  </entry>
  
  <entry>
    <title>Python으로 이베스트증권 xingAPI 깔끔하게 사용하기 (w/ pandas)</title>
    <link href="https://hwangheek.github.io/2021/neat-xingapi-with-python/"/>
    <id>https://hwangheek.github.io/2021/neat-xingapi-with-python/</id>
    <published>2021-01-04T09:38:14.000Z</published>
    <updated>2022-07-23T14:39:52.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h1><p>이베스트증권은 COM 형태와 dll 형태로 사용할 수 있는 xingAPI를 제공합니다. Python에서 COM object를 사용하는 라이브러리를 사용하면 xingAPI를 사용할 수 있지만, 사용법이 깔끔하지 못합니다.</p><img src="/images/2021-01-syntactic-sugar.jpg" class="Put some sugar on that" width="500" title="Sugar"><p>개인적으로 사용하기 위하여 설탕을 팍팍쳐서 모듈을 만들었습니다. 이 모듈을 사용하면, 코드가 다음과 같이 정리가 됩니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ebest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ebest.login()</span><br><span class="line">[*] 접속 서버 ((r)eal / (D)emo / (a)ce) : <span class="comment"># r</span></span><br><span class="line">[*] 아이디 : <span class="comment"># username</span></span><br><span class="line">[*] 패스워드 : <span class="comment"># password</span></span><br><span class="line">[*] 공인인증서 암호 : <span class="comment"># cert_password</span></span><br><span class="line">[*] 로그인 성공</span><br><span class="line"></span><br><span class="line"><span class="comment"># XAQuery 요청</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ebest.query(<span class="string">&#x27;t1101&#x27;</span>, <span class="built_in">dict</span>(shcode=<span class="string">&#x27;000020&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;t1101OutBlock&#x27;</span>: &#123;<span class="string">&#x27;hname&#x27;</span>: <span class="string">&#x27;동화약품&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;price&#x27;</span>: <span class="number">19100</span>,</span><br><span class="line">  <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;change&#x27;</span>: <span class="number">550</span>,</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="string">&#x27;open&#x27;</span>: <span class="number">19750</span>,</span><br><span class="line">  <span class="string">&#x27;high&#x27;</span>: <span class="number">19900</span>,</span><br><span class="line">  <span class="string">&#x27;low&#x27;</span>: <span class="number">18850</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># XAQuery 요청 후 DataFrame 형태로 변환</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = query(<span class="string">&#x27;t8413&#x27;</span>, <span class="built_in">dict</span>(</span><br><span class="line"><span class="meta">... </span>  shcode=<span class="string">&#x27;000020&#x27;</span>, sdate=<span class="string">&#x27;20200101&#x27;</span>, edate=<span class="string">&#x27;20210101&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>  gubun=<span class="string">&#x27;2&#x27;</span>, qrycnt=<span class="number">2000</span>, cts_date=<span class="string">&#x27; &#x27;</span>, comp_yn=<span class="string">&#x27;Y&#x27;</span></span><br><span class="line"><span class="meta">... </span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.DataFrame(res.get(<span class="string">&#x27;t8413OutBlock1&#x27;</span>)).set_index(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">           <span class="built_in">open</span>   high    low  close  ...  rate  pricechk  ratevalue  sign</span><br><span class="line">date                                  ...                                 </span><br><span class="line"><span class="number">20200102</span>   <span class="number">8340</span>   <span class="number">8400</span>   <span class="number">8290</span>   <span class="number">8400</span>  ...   <span class="number">0.0</span>         <span class="number">0</span>          <span class="number">0</span>     <span class="number">2</span></span><br><span class="line"><span class="number">20200103</span>   <span class="number">8400</span>   <span class="number">8450</span>   <span class="number">8290</span>   <span class="number">8360</span>  ...   <span class="number">0.0</span>         <span class="number">0</span>          <span class="number">0</span>     <span class="number">5</span></span><br><span class="line">         ...    ...    ...    ...  ...   ...       ...        ...   ...</span><br><span class="line"><span class="number">20201229</span>  <span class="number">18750</span>  <span class="number">19400</span>  <span class="number">18750</span>  <span class="number">19150</span>  ...   <span class="number">0.0</span>         <span class="number">0</span>          <span class="number">0</span>     <span class="number">2</span></span><br><span class="line"><span class="number">20201230</span>  <span class="number">19100</span>  <span class="number">19800</span>  <span class="number">18800</span>  <span class="number">19650</span>  ...   <span class="number">0.0</span>         <span class="number">0</span>          <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">[<span class="number">248</span> rows x <span class="number">11</span> columns]</span><br><span class="line"></span><br><span class="line"><span class="comment"># XAReal 실시간 데이터 구독 후 callback function으로 처리</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nws = Realtime(<span class="string">&#x27;NWS&#x27;</span>, callback=<span class="built_in">print</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nws.subscribe(<span class="string">&#x27;NWS001&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Realtime.listen()</span><br><span class="line">NWS &#123;<span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;20210104&#x27;</span>, <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;154734&#x27;</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;[포토] 코로나19 직무 교육현장 참관&#x27;</span>&#125;</span><br><span class="line">NWS &#123;<span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;20210104&#x27;</span>, <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;154752&#x27;</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;전성배 신임원장, &quot;국가 디지털전환 선도&quot;&#x27;</span>&#125;</span><br><span class="line">NWS &#123;<span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;20210104&#x27;</span>, <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;154750&#x27;</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;[포토] 정총리, 코로나19 교육현장 참관&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><a href="/assets/ebest.py">여기를 클릭</a>하시면 소스코드를 직접 확인하실 수 있고, 위 예시처럼 사용하실 수 있습니다. <strong>모듈을 어떻게 구현하였는지 궁금하신 경우</strong>, 모듈의 소스코드를 실행 순서별로 설명을 해 놓은 <strong>본 포스팅의 본문을 확인하시면 되겠습니다.</strong></p><p>개인적으로 사용하기 위해 구현한 코드인 관계로, 이런저런 문제점들이 많습니다. 😅 포스팅의 내용이나 소스에 개선이 필요한 경우, 피드백을 주시면 감사하겠습니다!</p><span id="more"></span><hr><h1 id="1-Requirements"><a href="#1-Requirements" class="headerlink" title="1. Requirements"></a>1. Requirements</h1><ul><li><p><strong>Python 3 (32-bit)</strong><br>xingAPI는 32bit COM을 제공하므로, 64bit python에서 사용할 수 없습니다. 64bit 환경에서 32bit COM을 작동하게 하는 <a href="https://techtalk.gfi.com/32bit-object-64bit-environment/">hacky한 방법</a>이 있긴 하지만 레지스터값을 일일히 수정해야하는 과정이 번거로우므로, 32bit 파이썬을 사용하는 방법이 편리합니다.<br>32bit python을 따로 설치하는 것도 방법이지만, anaconda를 사용중이라면 아래와 같이 virtual environment를 이용하여 빠르게 환경을 구축할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">set</span> CONDA_FORCE_32BIT=1</span><br><span class="line">$ conda create -n py37_32 python=3.7</span><br><span class="line">$ activate py37_32</span><br></pre></td></tr></table></figure></li><li><p><strong>xingAPI</strong><br>이베스트증권사의 xingAPI 설치파일을 통해 API를 설치합니다. 이후, 다음 두 가지 작업이 필요합니다.</p></li></ul><ol><li><code>C:\eBEST\xingAPI\reg.bat</code> (혹은 <code>(xingAPI 설치경로)\reg.bat</code>)을 실행시켜 dll 등록</li><li>DevCenter의 ‘Res 파일을 모두 다운로드’ 버튼을 클릭하여 res파일을 다운로드</li></ol><ul><li><p><strong>pypiwin32</strong><br>Python에서 COM을 사용하기 위한 라이브러리 <code>pypiwin32</code>를 설치합니다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install pypiwin32</span><br></pre></td></tr></table></figure></li><li><p><strong>… and other libraries</strong><br>모듈에서 사용된 라이브러리는 아래와 같습니다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, re, sys, time, pytz</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">&#x27;win32&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> win32com.client <span class="keyword">import</span> DispatchWithEvents</span><br><span class="line">    <span class="keyword">from</span> pythoncom <span class="keyword">import</span> PumpWaitingMessages</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;xingAPI는 윈도우 환경에서만 사용 가능합니다&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-사용-가능한-res-파일-정보-읽어오기"><a href="#2-사용-가능한-res-파일-정보-읽어오기" class="headerlink" title="2. 사용 가능한 res 파일 정보 읽어오기"></a>2. 사용 가능한 res 파일 정보 읽어오기</h1><p>xingAPI가 설치되어 있는 경로를 아래와 같이 명시해줍니다. 특별히 설치 경로를 변경하지 않았다면, <code>C:\eBEST\xingAPI\</code> 폴더에 위치해 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">XINGAPI_PATH = <span class="string">&#x27;/eBEST/xingAPI/&#x27;</span></span><br></pre></td></tr></table></figure><p>모듈이 로딩되는 시점에, 아래와 같이 xingAPI에서 제공하는 res 파일들에 대한 정보를 읽고 변수 <code>meta_res</code>에 저장해둡니다. 서버로부터 요청에 대한 응답을 수신할 때 제공되는 res 정보를 통해 데이터를 dictionary 형태로 formatting 하는데 사용할 수 있습니다. 이를 통해, 코드의 가독성을 높여주고, 타 라이브러리 (i.e. pandas)와의 호환성을 높일 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_meta_res</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; res 파일들의 meta data</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Example</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; build_meta_res()</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &#x27;t8413&#x27;: &#123;</span></span><br><span class="line"><span class="string">                &#x27;desc&#x27;: &#x27;주식챠트(일주월)&#x27;,</span></span><br><span class="line"><span class="string">                &#x27;input&#x27;: &#123;</span></span><br><span class="line"><span class="string">                    &#x27;t8413InBlock&#x27;: &#123;</span></span><br><span class="line"><span class="string">                        &#x27;occurs&#x27;: False,</span></span><br><span class="line"><span class="string">                        &#x27;fields&#x27;: [</span></span><br><span class="line"><span class="string">                            &#123;</span></span><br><span class="line"><span class="string">                                &#x27;name&#x27;: &#x27;shcode&#x27;,</span></span><br><span class="line"><span class="string">                                &#x27;desc&#x27;: &#x27;단축코드&#x27;,</span></span><br><span class="line"><span class="string">                                &#x27;type&#x27;: &#x27;char&#x27;,</span></span><br><span class="line"><span class="string">                                &#x27;size&#x27;: 6</span></span><br><span class="line"><span class="string">                            &#125;,</span></span><br><span class="line"><span class="string">                            &#123; ... &#125;,</span></span><br><span class="line"><span class="string">                            ...</span></span><br><span class="line"><span class="string">                        ]</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#x27;output&#x27;: &#123;</span></span><br><span class="line"><span class="string">                    &#x27;t8413OutBlock1&#x27;: &#123;</span></span><br><span class="line"><span class="string">                        &#x27;occurs&#x27;: True,</span></span><br><span class="line"><span class="string">                        &#x27;fields&#x27;: [ &#x27;price&#x27;, ... ]</span></span><br><span class="line"><span class="string">                    &#125;,</span></span><br><span class="line"><span class="string">                    ...</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    meta = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    fnames = <span class="built_in">filter</span>(</span><br><span class="line">        <span class="keyword">lambda</span> x: <span class="keyword">not</span> re.match(<span class="string">r&#x27;.*\_\d+\.res$&#x27;</span>, x),</span><br><span class="line">        os.listdir(os.path.join(XINGAPI_PATH, <span class="string">&#x27;res&#x27;</span>))</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_field</span>(<span class="params">line</span>):</span><br><span class="line">        cols = line.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: cols[<span class="number">1</span>].strip(),</span><br><span class="line">            <span class="string">&#x27;desc&#x27;</span>: cols[<span class="number">0</span>].strip(),</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: cols[<span class="number">3</span>].strip(),</span><br><span class="line">            <span class="string">&#x27;size&#x27;</span>: cols[<span class="number">4</span>].strip()</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_file</span>(<span class="params">lines</span>):</span><br><span class="line">        parsed = &#123;&#125;</span><br><span class="line">        lines = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;&#x27;</span>).strip(), lines))</span><br><span class="line">        lines = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x, lines))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;.Func&#x27;</span> <span class="keyword">in</span> lines[i] <span class="keyword">or</span> <span class="string">&#x27;.Feed&#x27;</span> <span class="keyword">in</span> lines[i]:</span><br><span class="line">                parsed[<span class="string">&#x27;desc&#x27;</span>] = lines[i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">            <span class="keyword">elif</span> lines[i] == <span class="string">&#x27;begin&#x27;</span>:</span><br><span class="line">                latest_begin = i</span><br><span class="line">            <span class="keyword">elif</span> lines[i] == <span class="string">&#x27;end&#x27;</span>:</span><br><span class="line">                block_info = lines[latest_begin-<span class="number">1</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> block_info[<span class="number">2</span>] <span class="keyword">in</span> parsed:</span><br><span class="line">                    parsed[block_info[<span class="number">2</span>]] = &#123;&#125;</span><br><span class="line">                </span><br><span class="line">                parsed[block_info[<span class="number">2</span>]][block_info[<span class="number">0</span>]] = &#123;</span><br><span class="line">                    <span class="string">&#x27;occurs&#x27;</span>: <span class="string">&#x27;occurs&#x27;</span> <span class="keyword">in</span> block_info,</span><br><span class="line">                    <span class="string">&#x27;fields&#x27;</span>: <span class="built_in">list</span>(<span class="built_in">map</span>(parse_field, lines[latest_begin+<span class="number">1</span>:i]))</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> parsed</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">        meta[fname.replace(<span class="string">&#x27;.res&#x27;</span>,<span class="string">&#x27;&#x27;</span>)] = parse_file(</span><br><span class="line">            <span class="built_in">open</span>(os.path.join(XINGAPI_PATH, <span class="string">&#x27;res/&#x27;</span>, fname)).readlines()</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> meta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">meta_res = build_meta_res()</span><br></pre></td></tr></table></figure><h1 id="3-서버에-접속하기-XASession"><a href="#3-서버에-접속하기-XASession" class="headerlink" title="3. 서버에 접속하기 : XASession"></a>3. 서버에 접속하기 : XASession</h1><p>Synchronous한 디자인에서 서버로 request를 하고 response를 받는 순서는 다음과 같습니다.</p><ol><li>서버 응답 등의 이벤트를 처리하는 ‘Event Listener Class’를 정의</li><li>위의 class를 사용하여, xingAPI의 COM object를 생성</li><li>해당 object의 <code>waiting</code> property를 <code>True</code>로 설정</li><li>COM object를 이용하여 서버로 데이터 요청</li><li>해당 object의 <code>waiting</code> property가 <code>True</code>인 경우, 반복적으로 <code>PumpWaitingMessages</code>를 호출<br>  5-1. 이벤트 발생 시, 이벤트 처리 class가 자신의 <code>waiting</code> property를 <code>False</code>로 설정<br>  5-2. 수신된 데이터가 있을 경우, 자신의 <code>response</code> property에 수신된 데이터를 저장</li><li>해당 object의 <code>response</code> property를 참조하여, 수신된 데이터를 확인</li></ol><p>서버에 접속하고 로그인하는 기능은 <code>XASession</code> COM에 명시되어 있습니다. COM object를 생성하기에 앞서서, 이벤트 발생 시 이를 처리할 Listener Class를 아래와 같이 선언합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_SessionHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OnLogin</span>(<span class="params">self, code, msg</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 서버와의 로그인이 끝나면 실행되는 함수</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            @arg code[str] 서버에서 받은 메시지 코드</span></span><br><span class="line"><span class="string">            @arg msg[str] 서버에서 받은 메시지 정보</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.waiting = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> code == <span class="string">&#x27;0000&#x27;</span>:</span><br><span class="line">            logger.info(<span class="string">&#x27;[*] 로그인 성공&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.warning(<span class="string">&#x27;[*] 로그인 실패 : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OnDisconnect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 서버와의 연결이 끊어졌을 때 실행되는 함수</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.waiting = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        logger.info(<span class="string">&#x27;[*] 서버와의 연결이 끊어졌습니다&#x27;</span>)</span><br></pre></td></tr></table></figure><p>위의 class를 사용하여, <code>XASession</code> COM object를 생성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">_session = DispatchWithEvents(<span class="string">&#x27;XA_Session.XASession&#x27;</span>, _SessionHandler)</span><br></pre></td></tr></table></figure><p>이제, <code>_session</code> object를 이용하여 xingAPI에 명시된 함수들을 호출할 수 있습니다. 예를들어, <code>ConnectServer</code>라는 함수를 호출하는 것은 아래와 같은 방법으로 가능합니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_session.ConnectServer(<span class="string">&#x27;hts.ebestsec.co.kr&#x27;</span>, <span class="number">20001</span>)</span><br></pre></td></tr></table></figure><p>이를 사용하여, 서버로 로그인을 하는 함수는 아래와 같이 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params"></span></span><br><span class="line"><span class="params">    server=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    username=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    password=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 로그인</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 기존에 연결되어 있는 서버가 있으면, 연결을 끊는다</span></span><br><span class="line">    <span class="keyword">if</span> _session.IsConnected():</span><br><span class="line">        _session.DisconnectServer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 로그인 시 필요한 정보를 입력받는다</span></span><br><span class="line">    login_server = (server <span class="keyword">or</span> <span class="built_in">input</span>(<span class="string">&#x27;[*] 접속 서버 ((r)eal / (D)emo / (a)ce) : &#x27;</span>)).lower()[:<span class="number">1</span>]</span><br><span class="line">    login_server = &#123;</span><br><span class="line">        <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;hts.ebestsec.co.kr&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;demo.ebestsec.co.kr&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    &#125;.get(login_server, <span class="string">&#x27;demo.ebestsec.co.kr&#x27;</span>)</span><br><span class="line">    login_port = <span class="number">20001</span></span><br><span class="line">    login_id = username <span class="keyword">or</span> <span class="built_in">input</span>(<span class="string">&#x27;[*] 아이디 : &#x27;</span>)</span><br><span class="line">    login_pw = password <span class="keyword">or</span> getpass(<span class="string">&#x27;[*] 패스워드 : &#x27;</span>)</span><br><span class="line">    login_cert = <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> login_server == <span class="string">&#x27;demo.ebestsec.co.kr&#x27;</span> <span class="keyword">else</span> getpass(<span class="string">&#x27;[*] 공인인증서 암호 : &#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 로그인 요청을 보낸다</span></span><br><span class="line">    _session.waiting = <span class="literal">True</span></span><br><span class="line">    _session.ConnectServer(login_server, login_port)</span><br><span class="line">    _session.Login(login_id, login_pw, login_cert, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> _session.waiting:</span><br><span class="line">        PumpWaitingMessages()</span><br><span class="line">        time.sleep(<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><h1 id="4-데이터-요청하기-XAQuery"><a href="#4-데이터-요청하기-XAQuery" class="headerlink" title="4. 데이터 요청하기 : XAQuery"></a>4. 데이터 요청하기 : XAQuery</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">res, send, cont=<span class="literal">False</span>, timeout=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Query 요청</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @arg res[str]`t1102` 사용할 res 파일명</span></span><br><span class="line"><span class="string">        @arg send[dict] 전송할 데이터</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &#x27;Block1&#x27;: [&#123;&#x27;Field1&#x27;: &#x27;Value1&#x27;, &#x27;Field2&#x27;: &#x27;Value2&#x27;&#125;, &#123;...&#125;, &#123;...&#125;],</span></span><br><span class="line"><span class="string">                &#x27;Block2&#x27;: &#123;&#x27;Field3&#x27;: &#x27;Value3&#x27;, &#x27;Field4&#x27;: &#x27;Value4&#x27;&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">            단일 InBlock의 경우에는 아래와 같이 간단한 형식도 입력받음</span></span><br><span class="line"><span class="string">            &#123;&#x27;Field1&#x27;: &#x27;Value1&#x27;, &#x27;Field2&#x27;: &#x27;Value2&#x27;&#125;</span></span><br><span class="line"><span class="string">        @arg cont[*bool=False] 연속조회 여부</span></span><br><span class="line"><span class="string">        @arg timeout[*int=10] 서버 응답 최대 대기 시간, -1인 경우 infinite time</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>결과적으로 함수가 호출되는 모습은 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query(<span class="string">&#x27;t1101&#x27;</span>, &#123;<span class="string">&#x27;shcode&#x27;</span>: <span class="string">&#x27;000020&#x27;</span>&#125;)</span><br><span class="line">query(<span class="string">&#x27;t1104&#x27;</span>, &#123;</span><br><span class="line">  <span class="string">&#x27;t1104InBlock&#x27;</span>: &#123;<span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;000020&#x27;</span>, <span class="string">&#x27;nrec&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;t1104InBlock1&#x27;</span>: [</span><br><span class="line">    &#123;<span class="string">&#x27;dat1&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;dat2&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;gubn&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;indx&#x27;</span>: <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;dat1&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;dat2&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;gubn&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;indx&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Query를 요청하고 결과를 수신하는 순서는 <code>XASession</code>과 동일합니다. 차이점은, <code>XAQuery</code> COM을 통해 Query 요청을 한다는 점입니다.<br>이벤트 class인 <code>_QueryHandler</code>가 구현되어 있다고 가정하고, <code>query</code> 함수를 아래와 같이 작성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">_query_status = &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">res, send, cont=<span class="literal">False</span>, timeout=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Query 요청</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @arg res[str]`t1102` 사용할 res 파일명</span></span><br><span class="line"><span class="string">        @arg send[dict] 전송할 데이터</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &#x27;Block1&#x27;: [&#123;&#x27;Field1&#x27;: &#x27;Value1&#x27;, &#x27;Field2&#x27;: &#x27;Value2&#x27;&#125;, &#123;...&#125;, &#123;...&#125;],</span></span><br><span class="line"><span class="string">                &#x27;Block2&#x27;: &#123;&#x27;Field3&#x27;: &#x27;Value3&#x27;, &#x27;Field4&#x27;: &#x27;Value4&#x27;&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">            단일 InBlock의 경우에는 아래와 같이 간단한 형식도 입력받음</span></span><br><span class="line"><span class="string">            &#123;&#x27;Field1&#x27;: &#x27;Value1&#x27;, &#x27;Field2&#x27;: &#x27;Value2&#x27;&#125;</span></span><br><span class="line"><span class="string">        @arg cont[*bool=False] 연속조회 여부</span></span><br><span class="line"><span class="string">        @arg timeout[*int=10] 서버 응답 최대 대기 시간, -1인 경우 infinite time</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># res 파일 로드</span></span><br><span class="line">    _query = DispatchWithEvents(<span class="string">&#x27;XA_DataSet.XAQuery&#x27;</span>, _QueryHandler)</span><br><span class="line">    _query.init(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cont:</span><br><span class="line">        <span class="comment"># 전송 현황 업데이트</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">in</span> _query_status:</span><br><span class="line">            _query_status[res] = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> _query_status[res] <span class="keyword">and</span> _query_status[res][-<span class="number">1</span>] + <span class="number">1</span> &lt; time.time():</span><br><span class="line">            _query_status[res].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 초당 전송 횟수를 고려</span></span><br><span class="line">        tr_count_per_sec = _query.GetTRCountPerSec(res)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(_query_status[res]) &gt;= tr_count_per_sec:</span><br><span class="line">            delay = <span class="built_in">max</span>(_query_status[res][-<span class="number">1</span>] + <span class="number">1.05</span> - time.time(), <span class="number">0</span>)</span><br><span class="line">            time.sleep(delay)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 기간(10분)당 전송 횟수를 고려</span></span><br><span class="line">        <span class="comment"># TODO : 10분 제한이 걸리면 blocking state 진입</span></span><br><span class="line">        tr_count_limit = _query.GetTRCountLimit(res)</span><br><span class="line">        <span class="keyword">while</span> tr_count_limit <span class="keyword">and</span> _query.GetTRCountRequest(res) &gt;= tr_count_limit:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            _query = DispatchWithEvents(<span class="string">&#x27;XA_DataSet.XAQuery&#x27;</span>, _QueryHandler)</span><br><span class="line">            _query.init(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># simplified 된 input를 받았을 경우</span></span><br><span class="line">    send_first_value = <span class="built_in">list</span>(send.values())[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (</span><br><span class="line">        <span class="built_in">isinstance</span> (send_first_value, <span class="built_in">list</span>) <span class="keyword">or</span></span><br><span class="line">        <span class="built_in">isinstance</span> (send_first_value, <span class="built_in">dict</span>)</span><br><span class="line">    ):</span><br><span class="line">        send = &#123; <span class="string">&#x27;&#123;&#125;InBlock&#x27;</span>.<span class="built_in">format</span>(res): send &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 전송할 데이터를 설정</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> send.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(send[block], <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">for</span> (k, v) <span class="keyword">in</span> send[block].items():</span><br><span class="line">                _query.set_data(block, k, v)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(send[block], <span class="built_in">list</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(send[block])):</span><br><span class="line">                <span class="keyword">for</span> (k, v) <span class="keyword">in</span> send[block][i].items():</span><br><span class="line">                    _query.set_data(block, k, v, i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;알 수 없는 형태의 데이터입니다&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time.sleep(<span class="number">0.05</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 요청</span></span><br><span class="line">    _query.Request(cont)</span><br><span class="line">    </span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cont:</span><br><span class="line">        _query_status[res].insert(<span class="number">0</span>, now)</span><br><span class="line">    _query.waiting = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> _query.waiting:</span><br><span class="line">        <span class="keyword">if</span> timeout &gt;= <span class="number">0</span> <span class="keyword">and</span> now + timeout &lt; time.time():</span><br><span class="line">            _query.waiting = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">raise</span> TimeoutError(<span class="string">&#x27;Query Timeout&#x27;</span>)</span><br><span class="line">        PumpWaitingMessages()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _query.response</span><br></pre></td></tr></table></figure><p><code>_QueryHandler</code>를 초기화(<code>init</code>)하고 요청을 위해 메시지를 준비(<code>set_data</code>)하는 method들을 구현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_QueryHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.response = &#123;&#125;</span><br><span class="line">        self.decomp = <span class="literal">False</span></span><br><span class="line">        self.qrycnt = <span class="literal">None</span></span><br><span class="line">        self.waiting = <span class="literal">False</span></span><br><span class="line">        self.res = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, res</span>):</span><br><span class="line">        self.LoadFromResFile(<span class="string">&#x27;/Res/&#123;&#125;.res&#x27;</span>.<span class="built_in">format</span>(res))</span><br><span class="line">        self.res = res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_data</span>(<span class="params">self, block, k, v, index=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">if</span> k == <span class="string">&#x27;comp_yn&#x27;</span> <span class="keyword">and</span> v.lower() == <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            self.decomp = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> k == <span class="string">&#x27;qrycnt&#x27;</span>:</span><br><span class="line">            self.qrycnt = <span class="built_in">int</span>(v)</span><br><span class="line">        </span><br><span class="line">        self.SetFieldData(block, k, index, v)</span><br></pre></td></tr></table></figure><p>이어서, 서버로부터 데이터 수신 시 불리는 이벤트 함수(<code>OnReceiveData</code>)와 이를 처리하는데 쓰이는 helper function(<code>get_block_data</code>)을 구현합니다. 이 과정에서, <strong>2. 사용 가능한 res 파일 정보 읽어오기</strong>에서 선언한 <code>meta_res</code>를 사용하여 결과를 formatting 해줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_QueryHandler</span>:</span><br><span class="line">  <span class="comment"># (... continued)</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_block_data</span>(<span class="params">self, block, index=<span class="number">0</span></span>):</span><br><span class="line">        block_data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> meta_res[self.res][<span class="string">&#x27;output&#x27;</span>][block][<span class="string">&#x27;fields&#x27;</span>]:</span><br><span class="line">            data = self.GetFieldData(block, field[<span class="string">&#x27;name&#x27;</span>], index)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> field[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;long&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> data == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    data = <span class="number">0</span></span><br><span class="line">                data = <span class="built_in">int</span>(data <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> field[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;double&#x27;</span> <span class="keyword">or</span> field[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;float&#x27;</span>:</span><br><span class="line">                data = <span class="built_in">float</span>(data <span class="keyword">or</span> <span class="number">0.0</span>)</span><br><span class="line">            </span><br><span class="line">            block_data[field[<span class="string">&#x27;name&#x27;</span>]] = data</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> block_data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OnReceiveData</span>(<span class="params">self, res</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 요청 데이터 도착 Listener</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            self.GetFieldData(...)를 통해 전송받은 데이터 확인이 가능하다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            @arg res[str] 요청 res 파일명</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># decompress가 필요한 경우 압축해제</span></span><br><span class="line">        <span class="comment"># TODO : OutBlock1 말고 다른 occurs가 있는 케이스 (ex. FOCCQ33600)</span></span><br><span class="line">        <span class="keyword">if</span> self.decomp:</span><br><span class="line">            self.Decompress(res + <span class="string">&#x27;OutBlock1&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> meta_res[res][<span class="string">&#x27;output&#x27;</span>].keys():</span><br><span class="line">            <span class="comment"># 해당 블럭이 occurs인 경우,</span></span><br><span class="line">            <span class="keyword">if</span> meta_res[res][<span class="string">&#x27;output&#x27;</span>][block][<span class="string">&#x27;occurs&#x27;</span>]:</span><br><span class="line">                row_res = []</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.GetBlockCount(block)):</span><br><span class="line">                    row_res.append(self.get_block_data(block, i))</span><br><span class="line">            <span class="comment"># 해당 블럭이 단일 데이터인 경우,</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row_res = self.get_block_data(block)</span><br><span class="line">        </span><br><span class="line">            self.response[block] = row_res</span><br><span class="line">        </span><br><span class="line">        self.waiting = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>결과적으로, <code>query</code>를 호출할 경우 아래와 같이 동작합니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>query(<span class="string">&#x27;t1101&#x27;</span>, &#123;<span class="string">&#x27;shcode&#x27;</span>: <span class="string">&#x27;000020&#x27;</span>&#125;)</span><br><span class="line">&#123;<span class="string">&#x27;t1101OutBlock&#x27;</span>: &#123;<span class="string">&#x27;bid&#x27;</span>: <span class="number">6780</span>,</span><br><span class="line">                   <span class="string">&#x27;bidho1&#x27;</span>: <span class="number">9700</span>,</span><br><span class="line">                   <span class="string">&#x27;bidho10&#x27;</span>: <span class="number">9600</span>,</span><br><span class="line">                   <span class="string">&#x27;bidho2&#x27;</span>: <span class="number">9690</span>,</span><br><span class="line">                   (...)</span><br><span class="line">                   <span class="string">&#x27;dnlmtprice&#x27;</span>: <span class="number">6750</span>,</span><br><span class="line">                   <span class="string">&#x27;high&#x27;</span>: <span class="number">9820</span>,</span><br><span class="line">                   <span class="string">&#x27;hname&#x27;</span>: <span class="string">&#x27;동화약품&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;ho_status&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">                   (...)</span><br><span class="line">                   <span class="string">&#x27;yeprice&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&#x27;yesign&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;yevolume&#x27;</span>: <span class="number">0</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="5-Wrapper-Functions"><a href="#5-Wrapper-Functions" class="headerlink" title="5. Wrapper Functions"></a>5. Wrapper Functions</h1><p>위의 <code>query</code> 함수를 한번 더 wrapping해서, 조금 더 직관적인 함수들을 만들 수 있습니다. 예를 들어, xingAPI에서는 <code>t8412</code>를 이용하여 주식차트를 분 단위로 가져올 수 있습니다. 한번에 가져올 수 있는 최대 데이터의 양인 2,000개가 넘는 데이터에 대해서는 연속조회도 지원합니다. 해당 res를 호출하는 <code>query</code> 함수를 다음과 같이 wrapping 할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transactions_min</span>(<span class="params">shcode, interval=<span class="number">1</span>, sdate=<span class="literal">None</span>, edate=<span class="literal">None</span></span>):</span><br><span class="line">  edate = edate <span class="keyword">or</span> datetime.now().strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">  sdate = sdate <span class="keyword">or</span> edate</span><br><span class="line">  </span><br><span class="line">  data = []</span><br><span class="line">  cts_date = <span class="string">&#x27; &#x27;</span></span><br><span class="line">  cts_time = <span class="string">&#x27; &#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    response = query(<span class="string">&#x27;t8412&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;shcode&#x27;</span>: shcode,</span><br><span class="line">      <span class="string">&#x27;ncnt&#x27;</span>: interval,</span><br><span class="line">      <span class="string">&#x27;qrycnt&#x27;</span>: <span class="number">2000</span>,</span><br><span class="line">      <span class="string">&#x27;nday&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;sdate&#x27;</span>: sdate,</span><br><span class="line">      <span class="string">&#x27;edate&#x27;</span>: edate,</span><br><span class="line">      <span class="string">&#x27;cts_date&#x27;</span>: cts_date,</span><br><span class="line">      <span class="string">&#x27;cts_time&#x27;</span>: cts_time,</span><br><span class="line">      <span class="string">&#x27;comp_yn&#x27;</span>: <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">    &#125;, <span class="built_in">len</span>(data) &gt; <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    data = response[<span class="string">&#x27;t8412OutBlock1&#x27;</span>] + data</span><br><span class="line">    cts_date = response[<span class="string">&#x27;t8412OutBlock&#x27;</span>][<span class="string">&#x27;cts_date&#x27;</span>]</span><br><span class="line">    cts_time = response[<span class="string">&#x27;t8412OutBlock&#x27;</span>][<span class="string">&#x27;cts_time&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (cts_date <span class="keyword">or</span> cts_time):</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line">  data = pd.DataFrame(data)</span><br><span class="line">  data.index = (data[<span class="string">&#x27;date&#x27;</span>] + data[<span class="string">&#x27;time&#x27;</span>]).apply(<span class="keyword">lambda</span> t: datetime.strptime(t, <span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>).astimezone(pytz.timezone(<span class="string">&#x27;Asia/Seoul&#x27;</span>)))</span><br><span class="line">  </span><br><span class="line">  data = data.rename(columns=&#123;<span class="string">&#x27;jdiff_vol&#x27;</span>: <span class="string">&#x27;volumn&#x27;</span>&#125;)</span><br><span class="line">  data = data[[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volumn&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;jongchk&#x27;</span>, <span class="string">&#x27;rate&#x27;</span>]]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p><code>query</code> 함수에서 결과물을 list of dict형태로 변환하므로, DataFrame 형태로 결과물을 바꾸는 작업이 간단해집니다. (<code>data = pd.DataFrame(data)</code>)</p><p>위의 <code>transactions_min</code> 함수는 다음과 같이 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transactions_min(<span class="string">&#x27;000020&#x27;</span>, interval=<span class="number">3</span>, sdate=<span class="string">&#x27;20201228&#x27;</span>)</span><br><span class="line">                            <span class="built_in">open</span>   high    low  ...  value  jongchk  rate</span><br><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">28</span> 09:03:<span class="number">00</span>+09:<span class="number">00</span>  <span class="number">20000</span>  <span class="number">20050</span>  <span class="number">19800</span>  ...    <span class="number">748</span>        <span class="number">0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">28</span> 09:06:<span class="number">00</span>+09:<span class="number">00</span>  <span class="number">19800</span>  <span class="number">19850</span>  <span class="number">19650</span>  ...    <span class="number">461</span>        <span class="number">0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">28</span> 09:09:<span class="number">00</span>+09:<span class="number">00</span>  <span class="number">19700</span>  <span class="number">19700</span>  <span class="number">19550</span>  ...    <span class="number">584</span>        <span class="number">0</span>   <span class="number">0.0</span></span><br><span class="line">                          ...    ...    ...  ...    ...      ...   ...</span><br><span class="line"><span class="number">2021</span>-01-04 <span class="number">15</span>:<span class="number">18</span>:<span class="number">00</span>+09:<span class="number">00</span>  <span class="number">19100</span>  <span class="number">19100</span>  <span class="number">19000</span>  ...    <span class="number">265</span>        <span class="number">0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">2021</span>-01-04 <span class="number">15</span>:<span class="number">20</span>:<span class="number">00</span>+09:<span class="number">00</span>  <span class="number">19000</span>  <span class="number">19100</span>  <span class="number">18950</span>  ...    <span class="number">138</span>        <span class="number">0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">2021</span>-01-04 <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+09:<span class="number">00</span>  <span class="number">19100</span>  <span class="number">19100</span>  <span class="number">19100</span>  ...    <span class="number">391</span>        <span class="number">0</span>   <span class="number">0.0</span></span><br><span class="line">[<span class="number">489</span> rows x <span class="number">8</span> columns]</span><br></pre></td></tr></table></figure><h1 id="6-실시간-데이터-구독하기-XAReal"><a href="#6-실시간-데이터-구독하기-XAReal" class="headerlink" title="6. 실시간 데이터 구독하기 : XAReal"></a>6. 실시간 데이터 구독하기 : XAReal</h1><p>실시간 데이터의 경우, XASession과 XAQuery와는 약간 다른 방법으로 데이터를 수신합니다.</p><ol><li>데이터 수신 이벤트를 처리하는 Event Listener Class를 정의</li><li>위의 class를 사용하여, xingAPI의 COM object를 생성</li><li>해당 object의 <code>callback</code> property를 데이터 수신 시 실행 할 함수로 설정</li><li>COM object를 이용하여 서버로 데이터 구독</li><li><code>PumpWaitingMessages</code>를 반복적으로 호출<br>  5-1. 데이터 수신 이벤트 발생 시, 이벤트 처리 class가 서버로부터 전달받은 데이터를 인자로 하여 <code>callback</code> property 함수를 실행</li><li>(구독한 데이터가 더 이상 필요가 없는 경우) COM object를 이용하여 구독 취소</li></ol><p>실시간 데이터를 위한 이벤트 리스너 클래스 (<code>_RealtimeHandler</code>)가 있다고 가정하고, 실시간 데이터 핸들링을 위한 클래스 <code>Realtime</code>을 구현하면 다음과 같습니다. xingAPI의 실시간 데이터의 경우 서버로 데이터를 요청할 시에 최대 하나의 field만 사용하므로, <code>meta_res</code>에서 해당 키 값의 이름을 가져와서 사용할 수 있습니다. (라인 357)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Realtime</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, res, callback</span>):</span><br><span class="line">        self._res = res</span><br><span class="line">        self._instance = DispatchWithEvents(<span class="string">&#x27;XA_DataSet.XAReal&#x27;</span>, _RealtimeHandler)</span><br><span class="line">        self._instance.LoadFromResFile(<span class="string">f&#x27;/Res/<span class="subst">&#123;res&#125;</span>.res&#x27;</span>)</span><br><span class="line">        self._instance.callback = callback</span><br><span class="line">        </span><br><span class="line">        self.subscribed_keys = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subscribe</span>(<span class="params">self, key=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.subscribed_keys:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self._res&#125;</span>는 이미 <span class="subst">&#123;key&#125;</span> 데이터를 수신 중입니다.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key:</span><br><span class="line">            self._instance.SetFieldData(<span class="string">&#x27;InBlock&#x27;</span>, meta_res[self._res][<span class="string">&#x27;input&#x27;</span>][<span class="string">&#x27;InBlock&#x27;</span>][<span class="string">&#x27;fields&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>], key)</span><br><span class="line">        self._instance.AdviseRealData()</span><br><span class="line">        </span><br><span class="line">        self.subscribed_keys.append(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unsubscribe</span>(<span class="params">self, key=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._instance.UnadviseRealData()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.subscribed_keys:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;self._res&#125;</span>는 <span class="subst">&#123;key&#125;</span> 데이터를 수신하고 있지 않습니다.&#x27;</span>)</span><br><span class="line">            self._instnace.UnadviseRealDataWithKey(key)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">delay=<span class="number">.01</span></span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            PumpWaitingMessages()</span><br><span class="line">            time.sleep(delay)</span><br></pre></td></tr></table></figure><p>마지막으로, 실시간 데이터를 수신했을 때 호출되는 <code>OnReceiveRealData</code>를 정의해줍니다. 위에서 설정한 <code>callback</code> 함수를 호출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_RealtimeHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OnReceiveRealData</span>(<span class="params">self, res</span>):</span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> meta_res[res][<span class="string">&#x27;output&#x27;</span>][<span class="string">&#x27;OutBlock&#x27;</span>][<span class="string">&#x27;fields&#x27;</span>]:</span><br><span class="line">            response[field[<span class="string">&#x27;name&#x27;</span>]] = self.GetFieldData(<span class="string">&#x27;OutBlock&#x27;</span>, field[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        self.callback(res, response)</span><br></pre></td></tr></table></figure><p>결과적으로, 위 코드를 사용하여 실시간 데이터를 요청하면 다음과 같이 실행이 됩니다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">res, response</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">if</span> res == <span class="string">&#x27;NWS&#x27;</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;현재시간 : <span class="subst">&#123;response[<span class="string">&quot;time&quot;</span>]&#125;</span> / 기사제목 : <span class="subst">&#123;response[<span class="string">&quot;title&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nws = Realtime(<span class="string">&#x27;NWS&#x27;</span>, callback=callback)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nws.subscribe(<span class="string">&#x27;NWS001&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Realtime.listen()</span><br><span class="line">현재시간 <span class="number">154734</span> / 기사제목 [포토] 코로나<span class="number">19</span> 직무 교육현장 참관</span><br><span class="line">현재시간 <span class="number">154752</span> / 기사제목 전성배 신임원장, <span class="string">&quot;국가 디지털전환 선도&quot;</span></span><br><span class="line">현재시간 <span class="number">154750</span> / 기사제목 [포토] 정총리, 코로나<span class="number">19</span> 교육현장 참관</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><code>_RealtimeHandler</code>가 인자로 <code>res</code>를 전달해주므로, <code>callback</code> 함수 내부적으로 어떤 실시간 데이터가 들어왔는지 구분할 수 있습니다.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-Introduction&quot;&gt;&lt;a href=&quot;#0-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0. Introduction&quot;&gt;&lt;/a&gt;0. Introduction&lt;/h1&gt;&lt;p&gt;이베스트증권은 COM 형태와 dll 형태로 사용할 수 있는 xingAPI를 제공합니다. Python에서 COM object를 사용하는 라이브러리를 사용하면 xingAPI를 사용할 수 있지만, 사용법이 깔끔하지 못합니다.&lt;/p&gt;
&lt;img src=&quot;/images/2021-01-syntactic-sugar.jpg&quot; class=&quot;Put some sugar on that&quot; width=&quot;500&quot; title=&quot;Sugar&quot;&gt;

&lt;p&gt;개인적으로 사용하기 위하여 설탕을 팍팍쳐서 모듈을 만들었습니다. 이 모듈을 사용하면, 코드가 다음과 같이 정리가 됩니다.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ebest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ebest.login()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[*] 접속 서버 ((r)eal / (D)emo / (a)ce) : &lt;span class=&quot;comment&quot;&gt;# r&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[*] 아이디 : &lt;span class=&quot;comment&quot;&gt;# username&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[*] 패스워드 : &lt;span class=&quot;comment&quot;&gt;# password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[*] 공인인증서 암호 : &lt;span class=&quot;comment&quot;&gt;# cert_password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[*] 로그인 성공&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# XAQuery 요청&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ebest.query(&lt;span class=&quot;string&quot;&gt;&amp;#x27;t1101&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;dict&lt;/span&gt;(shcode=&lt;span class=&quot;string&quot;&gt;&amp;#x27;000020&amp;#x27;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;t1101OutBlock&amp;#x27;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;hname&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;동화약품&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;price&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;19100&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;sign&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;5&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;change&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;550&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;open&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;19750&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;high&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;19900&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;low&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;18850&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# XAQuery 요청 후 DataFrame 형태로 변환&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;res = query(&lt;span class=&quot;string&quot;&gt;&amp;#x27;t8413&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;dict&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;  shcode=&lt;span class=&quot;string&quot;&gt;&amp;#x27;000020&amp;#x27;&lt;/span&gt;, sdate=&lt;span class=&quot;string&quot;&gt;&amp;#x27;20200101&amp;#x27;&lt;/span&gt;, edate=&lt;span class=&quot;string&quot;&gt;&amp;#x27;20210101&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;  gubun=&lt;span class=&quot;string&quot;&gt;&amp;#x27;2&amp;#x27;&lt;/span&gt;, qrycnt=&lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;, cts_date=&lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt;, comp_yn=&lt;span class=&quot;string&quot;&gt;&amp;#x27;Y&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;pd.DataFrame(res.get(&lt;span class=&quot;string&quot;&gt;&amp;#x27;t8413OutBlock1&amp;#x27;&lt;/span&gt;)).set_index(&lt;span class=&quot;string&quot;&gt;&amp;#x27;date&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;open&lt;/span&gt;   high    low  close  ...  rate  pricechk  ratevalue  sign&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date                                  ...                                 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;20200102&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8340&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8400&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8290&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8400&lt;/span&gt;  ...   &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;         &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;20200103&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8400&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8450&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8290&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8360&lt;/span&gt;  ...   &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;         &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         ...    ...    ...    ...  ...   ...       ...        ...   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;20201229&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;18750&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;19400&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;18750&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;19150&lt;/span&gt;  ...   &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;         &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;20201230&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;19100&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;19800&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;18800&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;19650&lt;/span&gt;  ...   &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;         &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;248&lt;/span&gt; rows x &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; columns]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# XAReal 실시간 데이터 구독 후 callback function으로 처리&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;nws = Realtime(&lt;span class=&quot;string&quot;&gt;&amp;#x27;NWS&amp;#x27;&lt;/span&gt;, callback=&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;nws.subscribe(&lt;span class=&quot;string&quot;&gt;&amp;#x27;NWS001&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;Realtime.listen()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NWS &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;date&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;20210104&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;time&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;154734&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;title&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;[포토] 코로나19 직무 교육현장 참관&amp;#x27;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NWS &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;date&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;20210104&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;time&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;154752&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;title&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;전성배 신임원장, &amp;quot;국가 디지털전환 선도&amp;quot;&amp;#x27;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NWS &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;date&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;20210104&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;time&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;154750&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;title&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;[포토] 정총리, 코로나19 교육현장 참관&amp;#x27;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/ebest.py&quot;&gt;여기를 클릭&lt;/a&gt;하시면 소스코드를 직접 확인하실 수 있고, 위 예시처럼 사용하실 수 있습니다. &lt;strong&gt;모듈을 어떻게 구현하였는지 궁금하신 경우&lt;/strong&gt;, 모듈의 소스코드를 실행 순서별로 설명을 해 놓은 &lt;strong&gt;본 포스팅의 본문을 확인하시면 되겠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;개인적으로 사용하기 위해 구현한 코드인 관계로, 이런저런 문제점들이 많습니다. 😅 포스팅의 내용이나 소스에 개선이 필요한 경우, 피드백을 주시면 감사하겠습니다!&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://hwangheek.github.io/tags/Python/"/>
    
    <category term="System Trading" scheme="https://hwangheek.github.io/tags/System-Trading/"/>
    
    <category term="ebest" scheme="https://hwangheek.github.io/tags/ebest/"/>
    
  </entry>
  
  <entry>
    <title>KRX의 휴장일 데이터를 기반으로 Python pandas의 AbstractHolidayCalendar와 CustomBusinessDay 사용하기</title>
    <link href="https://hwangheek.github.io/2020/pandas-custom-businessday-from-krx/"/>
    <id>https://hwangheek.github.io/2020/pandas-custom-businessday-from-krx/</id>
    <published>2020-10-28T03:13:26.000Z</published>
    <updated>2022-07-23T14:39:52.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h1><p>Python을 사용해서 금융 시계열 분석을 하다보면, datetime과 관련한 처리가 까다로운 경우가 많습니다. 대표적으로, 휴일 및 공휴일 등을 계산하는 경우가 있습니다. Python pandas 라이브러리에 business day 개념이 있기는 하지만 (기본적으로는) 주말을 제외한 공휴일을 제대로 고려하지 못합니다.</p><img src="/images/2020-10-say-datetime-one-more-time.jpg" class="datetime anger" width="500" title="datetime anger"><p>조금 찾아보니, pandas에서 이러한 문제를 관리할 수 있는 방법이 있었습니다. 본 포스팅은 해당 내용을 공부하며 정리한 글 입니다. 글의 내용 중 잘못 된 부분이 있는 경우, 피드백을 주시면 감사하겠습니다. :)</p><span id="more"></span><hr><h1 id="1-pandas의-AbstractHolidayCalendar"><a href="#1-pandas의-AbstractHolidayCalendar" class="headerlink" title="1. pandas의 AbstractHolidayCalendar"></a>1. pandas의 <code>AbstractHolidayCalendar</code></h1><h2 id="1-1-pandas의-Holiday를-사용하여-정의하기"><a href="#1-1-pandas의-Holiday를-사용하여-정의하기" class="headerlink" title="1.1. pandas의 Holiday를 사용하여 정의하기"></a>1.1. pandas의 <code>Holiday</code>를 사용하여 정의하기</h2><p>pandas의 <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html?highlight=abstractholidaycalendar#holidays-holiday-calendars"><em><code>AbstractHolidayCalendar</code></em></a>를 사용하여, 사용자가 공휴일을 직접 명시할 수 있습니다. 해당 클래스를 상속하는 클래스를 정의하고, 공휴일에 대한 정보를 담고 있는 클래스 변수 <code>rules</code>를 override 하면 됩니다. 각 공휴일은 pandas의 <code>Holiday</code> 클래스를 이용하여 아래와 같이 입력해줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.holiday <span class="keyword">import</span> AbstractHolidayCalendar, Holiday</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleCalendar</span>(<span class="title class_ inherited__">AbstractHolidayCalendar</span>):</span><br><span class="line">    rules = [</span><br><span class="line">      Holiday(<span class="string">&#x27;Example Holiday&#x27;</span>, month=<span class="number">3</span>, day=<span class="number">21</span>),</span><br><span class="line">      Holiday(<span class="string">&#x27;Another Example Holiday&#x27;</span>, year=<span class="number">2018</span>, month=<span class="number">8</span>, day=<span class="number">14</span>),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p><code>Holiday</code> 클래스의 경우 <code>offset</code> 혹은 <code>observance</code> 인자를 통해 조금 더 상세한 설정이 가능합니다.</p><p><code>offset</code>은 명시된 일자와 실제 공휴일 간의 일자 차이를 의미합니다. 주로 <code>pandas.DateOffset</code>과 함께 사용하여 “셋째 주 월요일”과 같은 식의 공휴일을 지정하는데 많이 사용됩니다.</p><p><code>observance</code>는 날짜로 주어진 공휴일에 대한 일종의 후처리 로직입니다. 주어진 날짜가 주말일 경우 공휴일을 다음주 월요일로 미룰지(<code>next_monday</code>), 주말 직전 금요일로 당길지(<code>previous_friday</code>) 등을 설정할 수 있습니다. pandas에서 기본적으로 제공되는 함수들을 사용하거나, 직접 정의한 함수를 사용할 수 있습니다.</p><p>실제 사용 예시를 확인하시면 이해가 쉽습니다. 아래는 pandas에서 기본적으로 제공되는 미국 공휴일 캘린더 클래스(<code>USFederalHolidayCalendar</code>)입니다. (pandas 1.1 기준으로, <a href="https://github.com/pandas-dev/pandas/blob/1.1.x/pandas/tseries/holiday.py"><em><code>pandas.tseries.holiday</code></em></a> 모듈에서 구현을 찾으실 수 있습니다.)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> DateOffset</span><br><span class="line"><span class="keyword">from</span> pandas.tseries.holiday <span class="keyword">import</span> AbstractHolidayCalendar, Holiday, nearest_workday</span><br><span class="line"><span class="keyword">from</span> dateutil.relativedelta <span class="keyword">import</span> MO, TU, WE, TH, FR, SA, SU</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USFederalHolidayCalendar</span>(<span class="title class_ inherited__">AbstractHolidayCalendar</span>):</span><br><span class="line">    rules = [</span><br><span class="line">        Holiday(</span><br><span class="line">          <span class="string">&quot;New Years Day&quot;</span>, month=<span class="number">1</span>, day=<span class="number">1</span>,</span><br><span class="line">          observance=nearest_workday  <span class="comment"># 1월 1일이 토요일인 경우 직전 금요일을,</span></span><br><span class="line">                                      <span class="comment"># 일요일인 경우 이후 월요일을 공휴일로 사용</span></span><br><span class="line">        ),</span><br><span class="line">        Holiday(</span><br><span class="line">          <span class="string">&quot;Martin Luther King Jr. Day&quot;</span>,</span><br><span class="line">          start_date=datetime(<span class="number">1986</span>, <span class="number">1</span>, <span class="number">1</span>), month=<span class="number">1</span>, day=<span class="number">1</span>,</span><br><span class="line">          offset=DateOffset(weekday=MO(<span class="number">3</span>))  <span class="comment"># 1986년 이후 1월의 셋째 주 월요일을 공휴일로 사용</span></span><br><span class="line">        ),</span><br><span class="line">        Holiday(</span><br><span class="line">          <span class="string">&quot;Presidents Day&quot;</span>,</span><br><span class="line">          month=<span class="number">2</span>, day=<span class="number">1</span>,</span><br><span class="line">          offset=DateOffset(weekday=MO(<span class="number">3</span>))  <span class="comment"># 2월 셋째 주 월요일을 공휴일로 사용</span></span><br><span class="line">        ),</span><br><span class="line">        Holiday(</span><br><span class="line">          <span class="string">&quot;Memorial Day&quot;</span>,</span><br><span class="line">          month=<span class="number">5</span>, day=<span class="number">31</span>,</span><br><span class="line">          offset=DateOffset(weekday=MO(-<span class="number">1</span>))  <span class="comment"># 5월 마지막 월요일을 공휴일로 사용</span></span><br><span class="line">        ),</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 이하 동일</span></span><br><span class="line">        Holiday(<span class="string">&quot;July 4th&quot;</span>, month=<span class="number">7</span>, day=<span class="number">4</span>, observance=nearest_workday),</span><br><span class="line">        Holiday(<span class="string">&quot;Labor Day&quot;</span>, month=<span class="number">9</span>, day=<span class="number">1</span>, offset=DateOffset(weekday=MO(<span class="number">1</span>))),</span><br><span class="line">        Holiday(<span class="string">&quot;Columbus Day&quot;</span>, month=<span class="number">10</span>, day=<span class="number">1</span>, offset=DateOffset(weekday=MO(<span class="number">2</span>))),</span><br><span class="line">        Holiday(<span class="string">&quot;Veterans Day&quot;</span>, month=<span class="number">11</span>, day=<span class="number">11</span>, observance=nearest_workday),</span><br><span class="line">        Holiday(<span class="string">&quot;Thanksgiving&quot;</span>, month=<span class="number">11</span>, day=<span class="number">1</span>, offset=DateOffset(weekday=TH(<span class="number">4</span>))),</span><br><span class="line">        Holiday(<span class="string">&quot;Christmas&quot;</span>, month=<span class="number">12</span>, day=<span class="number">25</span>, observance=nearest_workday),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="1-2-DB-정보를-사용하여-정의하기"><a href="#1-2-DB-정보를-사용하여-정의하기" class="headerlink" title="1.2. DB 정보를 사용하여 정의하기"></a>1.2. DB 정보를 사용하여 정의하기</h2><p>위와 같은 방법의 경우, 비주기적인 공휴일이 발생했을 때 소스코드를 수정해 주어야 합니다. 뿐만 아니라 음력으로 공휴일을 세는 경우가 많은 한국의 경우 위의 방법을 사용하기가 애매합니다. 만약 공휴일 혹은 휴장일 파일 혹은 데이터베이스를 구축해 놓은 경우, 위의 코드를 응용하여 데이터베이스의 최신 내용을 기반으로 하는 캘린더를 정의할 수 있습니다.</p><p>아래는 DB에서 가져온 공유일 데이터 <code>holidays</code>를 사용하여 공휴일 캘린더를 정의하는 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.holiday <span class="keyword">import</span> AbstractHolidayCalendar, Holiday</span><br><span class="line"></span><br><span class="line">holidays = get_holidays_from_your_db()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  (&#x27;어린이날&#x27;, 2020, 5, 5),</span></span><br><span class="line"><span class="string">  (&#x27;추석연휴&#x27;, 2020, 9, 30),</span></span><br><span class="line"><span class="string">  (&#x27;추석연휴&#x27;, 2020, 10, 1),</span></span><br><span class="line"><span class="string">  (&#x27;추석연휴&#x27;, 2020, 10, 2),</span></span><br><span class="line"><span class="string">  (&#x27;한글날&#x27;, 2020, 10, 9),</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleCalendar</span>(<span class="title class_ inherited__">AbstractHolidayCalendar</span>):</span><br><span class="line">    rules = [</span><br><span class="line">        Holiday(holiday[<span class="number">0</span>], year=holiday[<span class="number">1</span>], month=holiday[<span class="number">2</span>], day=holiday[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">for</span> holiday <span class="keyword">in</span> holidays</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="1-3-Deprecated-한국거래소-휴장일-정보를-크롤링하여-정의하기"><a href="#1-3-Deprecated-한국거래소-휴장일-정보를-크롤링하여-정의하기" class="headerlink" title="1.3. (Deprecated) 한국거래소 휴장일 정보를 크롤링하여 정의하기"></a>1.3. (Deprecated) 한국거래소 휴장일 정보를 크롤링하여 정의하기</h2><blockquote><p>현재 한국거래소 홈페이지의 레이아웃이 포스팅을 업로드 할 당시의 구조에서 많이 개선&#x2F;변경이 되었습니다. 😂<br>이에 따라, (1.3.) 섹션은 현재 정상적으로 구동이 되지 않지만, 참고하실 수 있도록 기록을 남겨두었습니다.</p></blockquote><p>한국거래소 홈페이지를 찾아보면 <a href="http://marketdata.krx.co.kr/mdi#document=01100305">휴장일 데이터</a>가 있습니다. 별도의 DB를 관리하지 않는 이상, 가장 정확한 한국거래소 개장일 정보가 될 것 같습니다. 아래는 KRX 홈페이지에서 휴장일 정보를 크롤링하여 리스트로 변환한 뒤, 이를 기반으로 캘린더를 정의하는 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> pandas.tseries.holiday <span class="keyword">import</span> AbstractHolidayCalendar, Holiday</span><br><span class="line"></span><br><span class="line">results = &#123;&#125;  <span class="comment"># &#123;year: holidays_of_the_year_in_csv_format&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2009</span>, <span class="number">2024</span>+<span class="number">1</span>):</span><br><span class="line">    res_otp = requests.get(</span><br><span class="line">        <span class="string">&#x27;http://marketdata.krx.co.kr/contents/COM/GenerateOTP.jspx&#x27;</span>,</span><br><span class="line">        params=&#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;fileDown&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filetype&#x27;</span>: <span class="string">&#x27;csv&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;MKD/01/0110/01100305/mkd01100305_01&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;search_bas_yy&#x27;</span>: year,</span><br><span class="line">        &#125;,</span><br><span class="line">        headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    otp = res_otp.text</span><br><span class="line">    </span><br><span class="line">    res_csv = requests.post(</span><br><span class="line">        <span class="string">&#x27;http://file.krx.co.kr/download.jspx&#x27;</span>,</span><br><span class="line">        headers=&#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://marketdata.krx.co.kr/mdi&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        data=urllib.parse.urlencode(&#123;<span class="string">&#x27;code&#x27;</span>:otp&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    results[year] = res_csv.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holidays = []</span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> results:</span><br><span class="line">    holidays.extend(</span><br><span class="line">        re.findall(</span><br><span class="line">            <span class="string">r&#x27;.*?\,(\d+)-(\d+)-(\d+)(?:\s\(.*?\))?\,(.*?)\s*\,(.*)&#x27;</span>,</span><br><span class="line">            results[year]</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">holidays = [</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    (&#x27;2020&#x27;, &#x27;01&#x27;, &#x27;27&#x27;, &#x27;월요일&#x27;, &#x27;설날(대체휴일)&#x27;),</span></span><br><span class="line"><span class="string">    (&#x27;2020&#x27;, &#x27;04&#x27;, &#x27;15&#x27;, &#x27;수요일&#x27;, &#x27;21대 국회의원선거&#x27;),</span></span><br><span class="line"><span class="string">    (&#x27;2020&#x27;, &#x27;04&#x27;, &#x27;30&#x27;, &#x27;목요일&#x27;, &#x27;석가탄신일&#x27;),</span></span><br><span class="line"><span class="string">    (&#x27;2020&#x27;, &#x27;05&#x27;, &#x27;01&#x27;, &#x27;금요일&#x27;, &#x27;근로자의날&#x27;),</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KRTradingCalendar</span>(<span class="title class_ inherited__">AbstractHolidayCalendar</span>):</span><br><span class="line">    rules = [</span><br><span class="line">        Holiday(holiday[<span class="number">4</span>], year=<span class="built_in">int</span>(holiday[<span class="number">0</span>]), month=<span class="built_in">int</span>(holiday[<span class="number">1</span>]), day=<span class="built_in">int</span>(holiday[<span class="number">2</span>]))</span><br><span class="line">        <span class="keyword">for</span> holiday <span class="keyword">in</span> holidays</span><br><span class="line">    ]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>특별한 점은 없지만, csv 형태의 데이터가 2014년 전후로 포맷이 약간 다릅니다. 이를 고려할 수 있도록 정규표현식을 잘 튜닝해 주어야 하겠습니다.</p><hr><h1 id="2-pandas의-CustomBusinessDay"><a href="#2-pandas의-CustomBusinessDay" class="headerlink" title="2. pandas의 CustomBusinessDay"></a>2. pandas의 <code>CustomBusinessDay</code></h1><p>위의 방법들로 정의한 공휴일 캘린더는 <code>CustomBusinessDay</code> 인스턴스를 생성할 때 인자로 전달할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> CustomBusinessDay</span><br><span class="line"></span><br><span class="line">TDay = TradingDay = CustomBusinessDay(calendar=KRTradingCalendar())</span><br></pre></td></tr></table></figure><p>이렇게 생성된 <code>TDay</code>는 다음과 같은 방법으로 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">TDay.holidays[<span class="number">155</span>:<span class="number">165</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot; 공휴일 리스트</span></span><br><span class="line"><span class="string">(numpy.datetime64(&#x27;2020-05-01&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-05-05&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-08-17&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-09-30&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-10-01&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-10-02&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-10-09&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-12-25&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2020-12-31&#x27;),</span></span><br><span class="line"><span class="string"> numpy.datetime64(&#x27;2021-01-01&#x27;))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>) + TDay    <span class="comment"># Timestamp(&#x27;2020-10-07 00:00:00&#x27;)</span></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>) + TDay*<span class="number">2</span>  <span class="comment"># Timestamp(&#x27;2020-10-08 00:00:00&#x27;)</span></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>) + TDay*<span class="number">3</span>  <span class="comment"># Timestamp(&#x27;2020-10-12 00:00:00&#x27;)</span></span><br><span class="line">                                     <span class="comment"># 공휴일(9일)과 주말(10~11일)을 스킵</span></span><br><span class="line"></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>) - TDay    <span class="comment"># Timestamp(&#x27;2020-10-05 00:00:00&#x27;)</span></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>) - TDay*<span class="number">2</span>  <span class="comment"># Timestamp(&#x27;2020-09-29 00:00:00&#x27;)</span></span><br><span class="line">                                     <span class="comment"># 주말(3~4일)과 공휴일(9월 30일~10월 2일)을 스킵</span></span><br><span class="line"></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>) + TDay - TDay <span class="comment"># Timestamp(&#x27;2020-10-06 00:00:00&#x27;)</span></span><br><span class="line">                                         <span class="comment"># 주어진 일자가 영업일인 경우, 해당 일자 반환</span></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">1</span>) + TDay - TDay <span class="comment"># Timestamp(&#x27;2020-09-29 00:00:00&#x27;)</span></span><br><span class="line">                                         <span class="comment"># 주어진 일자가 영업일이 아닐 경우,</span></span><br><span class="line">                                         <span class="comment"># 해당 일자에서 가장 가까운 *이전* 영업일</span></span><br><span class="line">datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">1</span>) - TDay + TDay <span class="comment"># Timestamp(&#x27;2020-10-05 00:00:00&#x27;)</span></span><br><span class="line">                                         <span class="comment"># 주어진 일자가 영업일이 아닐 경우,</span></span><br><span class="line">                                         <span class="comment"># 해당 일자에서 가장 가까운 *이후* 영업일</span></span><br><span class="line"></span><br><span class="line">pd.date_range(<span class="string">&#x27;2020-10-01&#x27;</span>, <span class="string">&#x27;2020-10-31&#x27;</span>, freq=TDay)</span><br><span class="line">pd.bdate_range(<span class="string">&#x27;2020-10-01&#x27;</span>, <span class="string">&#x27;2020-10-31&#x27;</span>, freq=TDay)</span><br><span class="line"><span class="string">&quot;&quot;&quot; 공휴일을 제외한 기간 내 영업일</span></span><br><span class="line"><span class="string">DatetimeIndex([&#x27;2020-10-05&#x27;, &#x27;2020-10-06&#x27;, &#x27;2020-10-07&#x27;, &#x27;2020-10-08&#x27;,</span></span><br><span class="line"><span class="string">               &#x27;2020-10-12&#x27;, &#x27;2020-10-13&#x27;, &#x27;2020-10-14&#x27;, &#x27;2020-10-15&#x27;,</span></span><br><span class="line"><span class="string">               &#x27;2020-10-16&#x27;, &#x27;2020-10-19&#x27;, &#x27;2020-10-20&#x27;, &#x27;2020-10-21&#x27;,</span></span><br><span class="line"><span class="string">               &#x27;2020-10-22&#x27;, &#x27;2020-10-23&#x27;, &#x27;2020-10-26&#x27;, &#x27;2020-10-27&#x27;,</span></span><br><span class="line"><span class="string">               &#x27;2020-10-28&#x27;, &#x27;2020-10-29&#x27;, &#x27;2020-10-30&#x27;],</span></span><br><span class="line"><span class="string">              dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;C&#x27;)  # freq=&#x27;C&#x27;는 &#x27;CustomBusinessDay&#x27;를 의미</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">np.busday_count(</span><br><span class="line">  <span class="string">&#x27;2020-10-01&#x27;</span>, <span class="string">&#x27;2020-10-31&#x27;</span>,</span><br><span class="line">  weekmask=TDay.weekmask,</span><br><span class="line">  holidays=TDay.holidays</span><br><span class="line">)</span><br><span class="line"><span class="string">&quot;&quot;&quot; 공휴일을 제외한 두 일자 간 영업일수</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>TDay</code>에 의해 변경된 결과값의 타입이 <code>pandas._libs.tslibs.timestamps.Timestamp</code>인 점을 인지하고 있어야 합니다. <code>datetime.date</code> 인스턴스가 들어가야 하는 위치에 <code>Timestamp</code> 인스턴스가 들어가는 경우, 가끔씩 type mismatch에 의한 에러가 발생할 수 있습니다. (예를 들면, <code>&#39;Timestamp&#39; object has no attribute &#39;...&#39;</code>) 이를 해결하기 위해서는, <code>Timestamp</code>의 <code>to_pydatetime()</code> method를 아래와 같이 사용하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">5</span>))  <span class="comment"># datetime.date</span></span><br><span class="line"><span class="built_in">type</span>(datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">5</span>) + TDay)  <span class="comment"># pandas._libs.tslibs.timestamps.Timestamp</span></span><br><span class="line"><span class="built_in">type</span>((datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">5</span>) + TDay).to_pydatetime())  <span class="comment"># datetime.datetime</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-Introduction&quot;&gt;&lt;a href=&quot;#0-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0. Introduction&quot;&gt;&lt;/a&gt;0. Introduction&lt;/h1&gt;&lt;p&gt;Python을 사용해서 금융 시계열 분석을 하다보면, datetime과 관련한 처리가 까다로운 경우가 많습니다. 대표적으로, 휴일 및 공휴일 등을 계산하는 경우가 있습니다. Python pandas 라이브러리에 business day 개념이 있기는 하지만 (기본적으로는) 주말을 제외한 공휴일을 제대로 고려하지 못합니다.&lt;/p&gt;
&lt;img src=&quot;/images/2020-10-say-datetime-one-more-time.jpg&quot; class=&quot;datetime anger&quot; width=&quot;500&quot; title=&quot;datetime anger&quot;&gt;

&lt;p&gt;조금 찾아보니, pandas에서 이러한 문제를 관리할 수 있는 방법이 있었습니다. 본 포스팅은 해당 내용을 공부하며 정리한 글 입니다. 글의 내용 중 잘못 된 부분이 있는 경우, 피드백을 주시면 감사하겠습니다. :)&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://hwangheek.github.io/tags/Python/"/>
    
    <category term="Pandas" scheme="https://hwangheek.github.io/tags/Pandas/"/>
    
    <category term="System Trading" scheme="https://hwangheek.github.io/tags/System-Trading/"/>
    
  </entry>
  
  <entry>
    <title>Pandas를 이용하여 틱데이터 가공하기</title>
    <link href="https://hwangheek.github.io/2020/pandas-tick-data/"/>
    <id>https://hwangheek.github.io/2020/pandas-tick-data/</id>
    <published>2020-04-20T04:34:30.000Z</published>
    <updated>2022-07-23T14:39:52.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h1><p>체결 데이터(틱데이터)를 사용할 때, 데이터가 지나치게 raw해서 생기는 난감한 부분들이 많습니다. 이를 해결하기 위해 “분봉”이나 “일봉”처럼, 일정한 시간을 기준으로 체결내역을 grouping하는 전처리 방법이 가장 많이 사용되는 것 같습니다. 이러한 방법의 장단점은 무엇일까요? 혹시 다른 방법은 없을까요? 어떻게 구현을 해야 할까요?</p><p><strong>Marcos Lopez de Prado의 저서 <em>Advances in Financial Machine Learning</em></strong>에 위 질문들에 대한 답변이 정리가 잘 되어있습니다. <strong>이번 포스팅은 해당 서적의 “2.3 Financial Data Structures: Bars” 챕터를 공부하며 이해한 내용을 정리한 내용입니다.</strong> 워낙 유명한 저서인지라, 책의 내용에 대한 구현을 정리해놓은 <a href="https://github.com/hudson-and-thames/mlfinlab">github repo</a>도 있습니다. 다만, 모듈화를 위해 로직이 흩어져있어서 이해하기가 쉽지 않아, Python pandas를 사용하여 직접 구현을 해보았습니다.</p><p>포스팅의 내용 혹은 코드에 개선이 필요한 경우, 피드백을 주시면 감사하겠습니다. :)</p><span id="more"></span><hr><p>시작하기에 앞서, 체결시각($t$)과 체결가격($p_t$, <code>price</code>), 체결량($v_t$, <code>volume</code>)으로 이루어진 <strong>틱 데이터</strong>가 필요합니다. 특별한 비용 없이도 증권사나 암호화폐 거래소 API를 사용하여 가져올 수 있습니다. 다음은 이베스트증권 API를 통해 받은 2020년 3월 25일 삼성전자(005930)의 틱데이터입니다. 추후 계산 편의를 위하여 거래대금($a_t$, <code>value</code>)을 $p_t\cdot v_t$로 미리 계산하였고, 인덱스로 사용된 체결시각을 오름차순으로 정렬했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>samsung = get_ticks(<span class="string">&#x27;005930&#x27;</span>, <span class="string">&#x27;20200325&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>samsung[<span class="string">&#x27;value&#x27;</span>] = samsung[<span class="string">&#x27;price&#x27;</span>] * samsung[<span class="string">&#x27;volume&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>samsung</span><br><span class="line">t                    price  volume       value</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:02  <span class="number">46950</span>      <span class="number">10</span>      <span class="number">469500</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:05  <span class="number">46950</span>      <span class="number">66</span>     <span class="number">3098700</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:<span class="number">10</span>  <span class="number">46950</span>       <span class="number">3</span>      <span class="number">140850</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:<span class="number">12</span>  <span class="number">46950</span>      <span class="number">87</span>     <span class="number">4084650</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">31</span>:<span class="number">21</span>  <span class="number">46950</span>      <span class="number">43</span>     <span class="number">2018850</span></span><br><span class="line"><span class="meta">... </span>                   ...     ...         ...</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">20</span>:06  <span class="number">48800</span>   <span class="number">20422</span>   <span class="number">996593600</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">28</span>  <span class="number">48850</span>   <span class="number">20486</span>  <span class="number">1000741100</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">28</span>  <span class="number">48850</span>   <span class="number">23020</span>  <span class="number">1124527000</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">12</span>  <span class="number">49000</span>   <span class="number">56124</span>  <span class="number">2750076000</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">15</span>  <span class="number">49050</span>   <span class="number">43268</span>  <span class="number">2122295400</span></span><br><span class="line">[<span class="number">226285</span> rows x <span class="number">3</span> columns]</span><br></pre></td></tr></table></figure><p>우리의 목표는 위 데이터를 이해하기 쉽고 사용하기 편한 (일종의) 테이블 형태로 변환하는 것입니다. 이러한 테이블의 행(row)을 <strong>“bar”</strong> 라고 부릅니다. 이번 포스팅에서는 bar를 추출하는 다양한 방법들을 소개합니다.</p><hr><h1 id="1-Standard-Bars"><a href="#1-Standard-Bars" class="headerlink" title="1. Standard Bars"></a>1. Standard Bars</h1><h2 id="1-1-Time-bars"><a href="#1-1-Time-bars" class="headerlink" title="1.1. Time bars"></a>1.1. Time bars</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><strong>일정한 시간 간격으로 bar를 추출하는 방법</strong>으로, 흔히 접하는 “분봉”, “일봉” 등이 이에 속합니다. 시간 흐름에 따른 가격과 수급 현황을 확인할 수 있어서 가장 직관적인 데이터 형태이지만, 몇 가지 문제점들이 있습니다.</p><ol><li>시장이 일정한 시간 단위로 정보를 처리하지 않습니다. 일정한 시간을 기준으로 데이터를 추출할 경우, 거래가 활발하지 않은 시기에는 데이터가 oversample 되고, 거래가 활발한 시기에는 undersample 되는 문제가 생깁니다.</li><li>일정한 시간으로 추출된 시계열 데이터의 통계 특성(i.e. serial correlation, heteroscedasticity, non-normality of returns)이 좋지 않은 경우가 많습니다.</li></ol><p>이러한 문제들은 (앞으로 소개 될) 거래 내역을 기반으로 데이터를 추출하는 방법을 통해 해결할 수 있습니다.</p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>시계열 DataFrame(DataFrame with datetime-like index)에는 주어진 규칙에 따라 데이터를 정렬 할 수 있는 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html"><code>resample</code></a> method가 있습니다. 이를 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.resample.Resampler.ohlc.html"><code>Resampler.ohlc</code></a>와 같이 사용하면, 틱 데이터를 쉽게 timebar로 변환할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timebar</span>(<span class="params">tick, rule</span>):</span><br><span class="line">    resample = tick.resample(rule)</span><br><span class="line">    </span><br><span class="line">    bars = resample[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 거래가 일어나지 않은 시간의 NaN 처리</span></span><br><span class="line">    bars[<span class="string">&#x27;close&#x27;</span>] = bars[<span class="string">&#x27;close&#x27;</span>].fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">    bars[<span class="string">&#x27;open&#x27;</span>]  = bars[<span class="string">&#x27;open&#x27;</span>].fillna(bars[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">    bars[<span class="string">&#x27;high&#x27;</span>]  = bars[<span class="string">&#x27;high&#x27;</span>].fillna(bars[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">    bars[<span class="string">&#x27;low&#x27;</span>]  = bars[<span class="string">&#x27;low&#x27;</span>].fillna(bars[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = resample[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timebar(samsung, <span class="string">&#x27;30s&#x27;</span>)</span><br><span class="line">t                       <span class="built_in">open</span>     high      low    close  volume       value</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:<span class="number">00</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>     <span class="number">166</span>     <span class="number">7793700</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:<span class="number">30</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>       <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">31</span>:<span class="number">00</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>      <span class="number">43</span>     <span class="number">2018850</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">31</span>:<span class="number">30</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>      <span class="number">31</span>     <span class="number">1455450</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">32</span>:<span class="number">00</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>  <span class="number">46950.0</span>      <span class="number">75</span>     <span class="number">3521250</span></span><br><span class="line"><span class="meta">... </span>                     ...      ...      ...      ...     ...         ...</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">00</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>       <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">30</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>       <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">59</span>:<span class="number">00</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>       <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">59</span>:<span class="number">30</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>  <span class="number">49000.0</span>       <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">49050.0</span>  <span class="number">49050.0</span>  <span class="number">49050.0</span>  <span class="number">49050.0</span>   <span class="number">43268</span>  <span class="number">2122295400</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1141</span> rows x <span class="number">6</span> columns]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timebar(samsung, <span class="string">&#x27;1H&#x27;</span>)</span><br><span class="line">t                     <span class="built_in">open</span>   high    low  close    volume         value</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">00</span>:<span class="number">00</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>       <span class="number">908</span>      <span class="number">42630600</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48900</span>  <span class="number">49600</span>  <span class="number">47550</span>  <span class="number">48050</span>  <span class="number">19104046</span>  <span class="number">930657231400</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48050</span>  <span class="number">48700</span>  <span class="number">47900</span>  <span class="number">48350</span>   <span class="number">6251831</span>  <span class="number">302241758300</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48350</span>  <span class="number">48450</span>  <span class="number">47800</span>  <span class="number">48300</span>   <span class="number">4902528</span>  <span class="number">235849172200</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48250</span>  <span class="number">48450</span>  <span class="number">48000</span>  <span class="number">48150</span>   <span class="number">2985362</span>  <span class="number">143843200950</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48100</span>  <span class="number">48200</span>  <span class="number">47150</span>  <span class="number">48100</span>   <span class="number">6703650</span>  <span class="number">320201734850</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48100</span>  <span class="number">48900</span>  <span class="number">47550</span>  <span class="number">48800</span>   <span class="number">7213952</span>  <span class="number">347588903150</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48850</span>  <span class="number">48900</span>  <span class="number">48450</span>  <span class="number">48650</span>   <span class="number">5089598</span>  <span class="number">247668090050</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48600</span>  <span class="number">48700</span>  <span class="number">48550</span>  <span class="number">48700</span>     <span class="number">88125</span>    <span class="number">4285782150</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48800</span>  <span class="number">49000</span>  <span class="number">48800</span>  <span class="number">49000</span>    <span class="number">172326</span>    <span class="number">8422908900</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">49050</span>  <span class="number">49050</span>  <span class="number">49050</span>  <span class="number">49050</span>     <span class="number">43268</span>    <span class="number">2122295400</span></span><br></pre></td></tr></table></figure><h2 id="1-2-Tick-bars"><a href="#1-2-Tick-bars" class="headerlink" title="1.2. Tick bars"></a>1.2. Tick bars</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p><strong>일정한 수의 체결이 발생하였을 때마다 bar를 추출하는 방법</strong>입니다. 체결이 많이 일어나는 시점에는 더 많은 bar가 추출되기 때문에, 시장으로 들어오는 정보의 속도를 time bar보다 잘 반영합니다. 또한, tick bar로 계산되는 수익률($r_i$)이 iid 정규분포에 더 가깝다는 연구도 있습니다. (<em>Ane &amp; Geman, 2000</em>)</p><p>하지만, 다음과 같은 점들이 문제가 될 수 있습니다.</p><ol><li>다수의 주문들이 한번에 체결되는 경우 outlier가 발생할 수 있습니다. 예를 들어, 장 마감 전 동시호가 시간(15:20~15:30)에는 주문이 체결되지 않고 누적되다가, 15:30분에 주문들이 한번에 체결되며 하나의 틱으로 처리가 됩니다. 하나의 틱이 수많은 체결을 포함하고 있는 셈입니다.</li><li>반대로, 하나의 주문이 여러번에 걸쳐 체결이 되는 경우도 문제가 됩니다. (a.k.a. “order fragmentation”) 정상적인 주문에 의한 다수의 체결인 경우에는 상관 없을 수 있지만, 트레이딩 봇에 의한 경우나 (운용&#x2F;개발 편의를 위해) 체결 엔진에 의한 경우에는 데이터에 왜곡이 생길 우려가 있습니다.</li></ol><h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>Tick bar는 time bar와 비슷한 방법으로 구현이 가능합니다. 이전과는 다르게, 체결 시각을 기준으로 데이터를 resampling 하는 것이 아니므로, 새로운 인덱스(<code>window_number</code>)를 추가한 뒤 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html"><code>groupby()</code></a> method를 통해 데이터를 묶어주었습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tickbar</span>(<span class="params">tick, window_size</span>):</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    tick[<span class="string">&#x27;window_number&#x27;</span>] = np.arange(<span class="built_in">len</span>(tick)) // window_size</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;window_number&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">    </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tickbar(samsung, <span class="number">10</span>)</span><br><span class="line">t                     <span class="built_in">open</span>   high    low  close  volume        value</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:02  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>     <span class="number">315</span>     <span class="number">14789250</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">32</span>:<span class="number">37</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>     <span class="number">338</span>     <span class="number">15869100</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">35</span>:<span class="number">51</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>     <span class="number">255</span>     <span class="number">11972250</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>  <span class="number">48900</span>  <span class="number">48950</span>  <span class="number">48900</span>  <span class="number">48900</span>    <span class="number">3150</span>    <span class="number">154048850</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>  <span class="number">48900</span>  <span class="number">48950</span>  <span class="number">48900</span>  <span class="number">48950</span>    <span class="number">9649</span>    <span class="number">471903050</span></span><br><span class="line"><span class="meta">... </span>                   ...    ...    ...    ...     ...          ...</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">11</span>  <span class="number">48650</span>  <span class="number">48650</span>  <span class="number">48650</span>  <span class="number">48650</span>     <span class="number">630</span>     <span class="number">30649500</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">26</span>  <span class="number">48650</span>  <span class="number">48650</span>  <span class="number">48650</span>  <span class="number">48650</span>    <span class="number">2275</span>    <span class="number">110678750</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">40</span>  <span class="number">48650</span>  <span class="number">48650</span>  <span class="number">48600</span>  <span class="number">48600</span>   <span class="number">15808</span>    <span class="number">768327150</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">23</span>  <span class="number">48600</span>  <span class="number">49000</span>  <span class="number">48550</span>  <span class="number">49000</span>  <span class="number">245810</span>  <span class="number">11997138450</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">15</span>  <span class="number">49050</span>  <span class="number">49050</span>  <span class="number">49050</span>  <span class="number">49050</span>   <span class="number">43268</span>   <span class="number">2122295400</span></span><br><span class="line"></span><br><span class="line">[<span class="number">22709</span> rows x <span class="number">6</span> columns]</span><br></pre></td></tr></table></figure><h2 id="1-3-Volume-bars"><a href="#1-3-Volume-bars" class="headerlink" title="1.3. Volume bars"></a>1.3. Volume bars</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p><strong>일정한 수준의 거래량이 발생할 때마다 bar를 추출하는 방법입니다.</strong> 거래량을 기준으로 데이터를 추출하기 때문에, order fragmentation에 의해 데이터가 왜곡되는 tick bar의 문제점을 어느정도 해결할 수 있습니다. Tick bar로 계산되는 수익률보다 volume bar로 계산되는 수익률이 iid 정규분포에 더 가깝다는 연구도 있습니다. (<em>Clark, 1973</em>) 이뿐만 아니라, 가격과 거래량의 상호작용에 대한 시장 미시구조 이론들을 적용하기에도 용이합니다.</p><p>다만, “거래량 하나”의 가치가 시장의 여러 요인들에 의해 지속적으로 변한다는 점을 감안해야 합니다. 따라서 가격 변동이 큰 데이터(ex. 암호화폐)를 사용하여 volume bar를 추출 할 경우, 각 bar의 “가치” 차이가 클 수 있습니다. 가격의 변동 뿐만 아니라, 유통 주식수에 영향을 주는 이벤트(주식발행, 액면 병합&#x2F;분할, 자사주 매입 등)도 단위 거래량의 가치를 변동시킬 수 있다는 점을 조심해야 합니다.</p><h3 id="Naive-Implementation"><a href="#Naive-Implementation" class="headerlink" title="(Naive) Implementation"></a>(Naive) Implementation</h3><p>모든 bar가 (정확하게) 동일한 단위 거래량을 가지도록 volume bar를 추출하기 위해서는 iteration이 필요해 보입니다. (누적 거래량이 단위 거래량을 넘어가는 순간, 하나의 틱을 여러개로 나눠야 하는 로직이 필요할 것 같습니다.) 이 경우, numpy의 효율적인 퍼포먼스를 충분히 활용하기가 어렵습니다.</p><p>Tick bar를 계산하는 방법을 응용하면, volume bar를 approximate 할 수 있는 bar를 아래와 같이 계산할 수 있습니다. 단위 거래량이 커질수록, 아래의 방법으로 계산 된 bar는 volume bar와 유사해집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">naive_volumebar</span>(<span class="params">tick, unit_volume</span>):</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    tick[<span class="string">&#x27;window_number&#x27;</span>] = tick[<span class="string">&#x27;volume&#x27;</span>].cumsum() // unit_volume</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;window_number&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">    </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>naive_volumebar(samsung, <span class="number">500_000</span>).head(<span class="number">10</span>)</span><br><span class="line">t                           <span class="built_in">open</span>   high    low  close   volume         value</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:02+09:<span class="number">00</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>      <span class="number">908</span>      <span class="number">42630600</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>  <span class="number">48950</span>  <span class="number">48500</span>  <span class="number">48750</span>  <span class="number">2999031</span>  <span class="number">146769006600</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">36</span>+09:<span class="number">00</span>  <span class="number">48800</span>  <span class="number">48850</span>  <span class="number">48350</span>  <span class="number">48500</span>   <span class="number">499415</span>   <span class="number">24269779250</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:01:07+09:<span class="number">00</span>  <span class="number">48450</span>  <span class="number">48800</span>  <span class="number">48450</span>  <span class="number">48750</span>   <span class="number">500462</span>   <span class="number">24323620400</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:01:<span class="number">47</span>+09:<span class="number">00</span>  <span class="number">48750</span>  <span class="number">49000</span>  <span class="number">48700</span>  <span class="number">49000</span>   <span class="number">480488</span>   <span class="number">23495366100</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:02:<span class="number">32</span>+09:<span class="number">00</span>  <span class="number">49000</span>  <span class="number">49250</span>  <span class="number">49000</span>  <span class="number">49250</span>   <span class="number">517832</span>   <span class="number">25422146200</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:03:08+09:<span class="number">00</span>  <span class="number">49250</span>  <span class="number">49500</span>  <span class="number">49200</span>  <span class="number">49500</span>   <span class="number">501844</span>   <span class="number">24769576200</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:03:<span class="number">55</span>+09:<span class="number">00</span>  <span class="number">49500</span>  <span class="number">49600</span>  <span class="number">49450</span>  <span class="number">49500</span>   <span class="number">498855</span>   <span class="number">24702622450</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:04:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">49500</span>  <span class="number">49600</span>  <span class="number">49250</span>  <span class="number">49400</span>   <span class="number">501011</span>   <span class="number">24745938700</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:05:<span class="number">46</span>+09:<span class="number">00</span>  <span class="number">49400</span>  <span class="number">49500</span>  <span class="number">49300</span>  <span class="number">49350</span>   <span class="number">500149</span>   <span class="number">24708946850</span></span><br></pre></td></tr></table></figure><p>거래가 상대적으로 적게 일어나는 종가매매 시간(08:30)과 시가단일가 주문이 한번에 체결되는 장 개시 시점(09:00)을 제외하면, 거래량이 50만주에 가깝게 bar들이 추출되었습니다. 참고로 <code>500_000</code>에서 underscore(<code>_</code>)는 가독성을 위하여 자릿수를 나누어 주는 역할을 하고, 실제 값은 <code>500000</code>과 동일합니다. (<a href="https://www.python.org/dev/peps/pep-0515/">PEP-515</a>)</p><h2 id="1-4-Dollar-bars"><a href="#1-4-Dollar-bars" class="headerlink" title="1.4. Dollar bars"></a>1.4. Dollar bars</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><p><strong>일정한 수준의 거래대금이 누적 될 때마다 bar를 추출하는 방법</strong>입니다. 실제 거래되는 현금의 양을 기준으로 데이터를 처리하기 때문에, volume bar에 비해 가격변동, 주식발행, 액면 병합&#x2F;분할, 자사주 매입 등의 이벤트에 대해 robust하고, 단위 거래량의 가치 변화에 조금 더 consistent 합니다.</p><p><img src="/images/2019-04-pandas-tick-data-snpf.png"></p><p>위 그림은 E-mini S&amp;P 500 선물 틱 데이터를 tick bar, volume bar, dollar bar로 계산한 뒤, 하루에 발생하는 bar의 개수를 나타낸 그래프입니다.(<em>Lopez de Prado, 2018</em>) 다른 데이터에 비해서 dollar bar가 더 consistent하게 추출되는 경향을 볼 수 있습니다. 더 나아가서, 각 bar를 추출하는 단위 거래대금의 크기를 유동적으로 조절하여(ex. 유동시가총액에 비례하는 단위), 보다 더 consistent한 데이터를 얻을 수 있겠습니다.</p><h3 id="Naive-Implementation-1"><a href="#Naive-Implementation-1" class="headerlink" title="(Naive) Implementation"></a>(Naive) Implementation</h3><p>거래량 또는 거래대금을 기준으로 bar를 추출한다는 점만 제외하면, dollar bar는 volume bar와 같은 로직을 가지고 있습니다. Volume bar의 구현을 참고하여 다음과 같이 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">naive_dollarbar</span>(<span class="params">tick, unit_value</span>):</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    tick[<span class="string">&#x27;window_number&#x27;</span>] = tick[<span class="string">&#x27;value&#x27;</span>].cumsum() // unit_value</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;window_number&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">    </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>naive_dollarbar(samsung, <span class="number">50_000_000_000</span>).head(<span class="number">10</span>)</span><br><span class="line">t                           <span class="built_in">open</span>   high    low  close   volume         value</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 08:<span class="number">30</span>:02+09:<span class="number">00</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>  <span class="number">46950</span>      <span class="number">908</span>      <span class="number">42630600</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>  <span class="number">48950</span>  <span class="number">48500</span>  <span class="number">48800</span>  <span class="number">3058052</span>  <span class="number">149640289350</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">40</span>+09:<span class="number">00</span>  <span class="number">48500</span>  <span class="number">48850</span>  <span class="number">48350</span>  <span class="number">48850</span>  <span class="number">1025849</span>   <span class="number">49868417850</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:01:<span class="number">58</span>+09:<span class="number">00</span>  <span class="number">48850</span>  <span class="number">49350</span>  <span class="number">48800</span>  <span class="number">49300</span>  <span class="number">1028290</span>   <span class="number">50435367200</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:03:<span class="number">21</span>+09:<span class="number">00</span>  <span class="number">49300</span>  <span class="number">49600</span>  <span class="number">49250</span>  <span class="number">49300</span>  <span class="number">1010431</span>   <span class="number">49977830750</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:04:<span class="number">58</span>+09:<span class="number">00</span>  <span class="number">49300</span>  <span class="number">49500</span>  <span class="number">49250</span>  <span class="number">49350</span>   <span class="number">972074</span>   <span class="number">48001468250</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:06:<span class="number">53</span>+09:<span class="number">00</span>  <span class="number">49300</span>  <span class="number">49350</span>  <span class="number">48750</span>  <span class="number">48800</span>  <span class="number">1060961</span>   <span class="number">52033926150</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:08:<span class="number">27</span>+09:<span class="number">00</span>  <span class="number">48800</span>  <span class="number">49150</span>  <span class="number">48650</span>  <span class="number">49100</span>  <span class="number">1023033</span>   <span class="number">49984091500</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">11</span>:<span class="number">17</span>+09:<span class="number">00</span>  <span class="number">49100</span>  <span class="number">49250</span>  <span class="number">48800</span>  <span class="number">48850</span>  <span class="number">1020253</span>   <span class="number">50014684300</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">14</span>:<span class="number">15</span>+09:<span class="number">00</span>  <span class="number">48850</span>  <span class="number">48850</span>  <span class="number">48350</span>  <span class="number">48400</span>  <span class="number">1028829</span>   <span class="number">49976391950</span></span><br></pre></td></tr></table></figure><p>Volume bar와 비슷한 이유로, 장 시작 직전과 직후를 제외하면, 각 bar의 거래대금이 50BnKRW에 가깝게 데이터가 처리되었습니다.</p><hr><h1 id="2-Information-Driven-Bars"><a href="#2-Information-Driven-Bars" class="headerlink" title="2. Information-Driven Bars"></a>2. Information-Driven Bars</h1><h2 id="2-0-The-tick-rule"><a href="#2-0-The-tick-rule" class="headerlink" title="2.0. The tick rule"></a>2.0. The tick rule</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><p><strong>Information-driven bar는 시장에 새로운 정보가 유입되었을 때, 더 많은 bar를 추출하는 접근방법</strong>입니다. 시장에 새로운 정보가 유입이 되었다는 사실은 어떻게 알 수 있을까요?</p><p>시장미시구조론에서는 다음과 같은 흐름으로 논리가 전개됩니다. 시장에 새로운 정보가 유입이 되었을 경우, 해당 정보를 참고하여 시장에 참여하는 “informed trader”들이 생깁니다. 이로 인해 가격은 새로운 균형점으로 이동하려고 하고, 그 과정에서 매도&#x2F;매수 세력이 불균형해집니다. 역으로 생각해보면, 이러한 불균형이 관찰이 된다면 시장에 새로운 정보가 반영되었다고 유추를 할 수 있습니다. 즉, 시장 외부 이벤트들을 (NLP 등을 이용하여) 직접 포착하는 것이 아니라, <strong>이벤트가 시장에 녹아들 때 발생하는 시장의 현상을 포착하는 것</strong>입니다.</p><p>이를 위해서는, “매도&#x2F;매수 세력의 불균형”을 수치화하여 활용해야 합니다. 한 가지 방법으로, 틱 데이터에 <strong>tick rule</strong>을 적용하여 <strong>signed tick (<escape>$b_t \in {-1, 1}$</escape>)</strong> 을 정의할 수 있습니다.</p><escape>\begin{equation*}    b_t=    \begin{cases}      b_{t-1} & \text{if } \Delta p_t=0 \\      \frac{\left|\Delta p_t\right|}{\Delta p_t} & \text{if } \Delta p_t\neq0    \end{cases}    \quad \text{or}\ \     b_t=    \begin{cases}      1       & \text{if } \Delta p_t &gt; 0 \\      -1      & \text{if } \Delta p_t &lt; 0 \\      b_{t-1} & \text{if } \Delta p_t=0    \end{cases}\end{equation*}</escape><p>복잡해 보이는 식이지만, 의미는 간단합니다. 거래가 직전 거래보다 높은 가격에 체결됐을 경우 1, 낮은 가격에 체결됐을 경우 -1, 같은 가격에 체결됐을 경우 $b_{t-1}$ 값을 그대로 사용하는 방법입니다.</p><p>Signed tick은 <strong><a href="https://www.investopedia.com/terms/a/aggressor.asp">trade’s agressor side</a>를 수치화하기 위한 알고리즘</strong>입니다. 거래가 체결되는 형태는 크게 “지정가 매도주문 + 시장가 매수주문”이 매칭이 되는 경우와 “시장가 매도주문 + 지정가 매수주문”이 매칭이 되는 경우가 있습니다. 매도호가가 매수호가보다 크기 때문에, 전자의 체결가가 더 높습니다. 즉, 직전 거래와 비교하였을 때 체결가가 높다면, 이번 거래는 시장가 매수주문에 의해 체결되었을 가능성이 높은 셈입니다. (아래 <em>Pitfall</em> 항목에서 언급하겠지만, 항상 그렇지는 않습니다.) 이를 반영하여 signed tick을 다르게 설명하면, <strong>시장가 매수주문에 의해 거래가 발생한 경우 $b_t&#x3D;1$, 시장가 매도주문에 의해 거래가 거래가 발생한 경우에는 $b_t&#x3D;-1$으로 정의하는 방법</strong>이라고 할 수 있습니다.</p><p>자산(혹은 계약)의 가격이 상승압력을 받게 되면 시장가 매수주문이 많이 발생하게 되고, $b_t&#x3D;1$인 경우가 상대적으로 많이 관찰이 될 것입니다. 따라서, $b_t&#x3D;1$인 경우가 어느 수준 이상 관찰될 때마다 bar를 추출하면, 시장에 유입되는 정보를 기준으로 bar를 추출할 수 있습니다. 반대의 경우($b_t&#x3D;-1$)도 마찬가지 입니다.</p><h3 id="Pitfall"><a href="#Pitfall" class="headerlink" title="Pitfall"></a>Pitfall</h3><p>호가가 변하는 경우, agressor side를 제대로 파악하지 못하는 문제가 생깁니다. 아래의 예시를 보겠습니다.</p><ol><li>매도호가 11,000원, 매수호가 10,000원인 주식, 이전 체결가 10,000원 ($p_0&#x3D;10000$)</li><li>$t&#x3D;1$ 시점에서 시장가 매수주문 접수, 체결 ($p_1&#x3D;11000$, $b_1&#x3D;1$)</li><li>지정가 매도주문 10,900원으로 접수. 현재 매도호가 10,900원, 매수호가 10,000원</li><li>$t&#x3D;2$ 시점에서 시장가 매수주문 접수, 체결 ($p_2&#x3D;10900$, $b_2&#x3D;-1 \because \Delta p_2&lt;0$)</li></ol><p>시장가 매수주문이 체결되었음에도, $b_2&#x3D;-1$이 되는 문제가 발생합니다. 매수주문과 매도주문이 균형있게 체결되는 시장에서 위의 문제는 시간이 지나면서 해소가 될 수 있습니다. 하지만 유동성이 부족하거나 변동이 큰 종목의 경우에는 문제가 될 소지가 있으므로, 이에 대해 인지를 하고 있어야 합니다.</p><p>사용하는 API에 따라, signed tick 정보를 제공하는 경우도 있습니다. 예를 들어 <a href="https://doc.coinone.co.kr/#operation/public_api_trades">코인원 API에서 제공하는 최근 체결 내역</a>의 경우, 체결 시각과 체결가, 체결량과 함께 agressor side를 명시한 <code>is_ask</code>라는 데이터를 함께 제공합니다. 이 경우, 해당 데이터를 signed tick으로 활용하는 방법도 고려해볼 수 있겠습니다.</p><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">signed_tick</span>(<span class="params">tick, initial_value=<span class="number">1.0</span></span>):</span><br><span class="line">    diff = tick[<span class="string">&#x27;price&#x27;</span>] - tick[<span class="string">&#x27;price&#x27;</span>].shift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(diff) / diff).ffill().fillna(initial_value)</span><br></pre></td></tr></table></figure><p>Signed tick을 계산하기 위해서 필요한 직전 거래의 체결가를 구하기 위해, pandas의 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.shift.html"><code>shift()</code></a> method를 사용합니다. 체결가에 변동이 없는 경우, <code>diff</code>가 0이 되어 <code>abs(diff)/diff</code> 값이 <code>np.nan</code>으로 계산되도록 한 뒤, <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ffill.html?highlight=ffill"><code>ffill()</code></a> (forward fill)을 통해 이전 값을 사용하도록 합니다. 틱 데이터의 앞 부분에서는 <code>signed_tick</code>이 정의될 수 없으므로, 임의의 값 (<code>initial_value=1.0</code>)을 넣어줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>samsung[<span class="string">&#x27;signed_tick&#x27;</span>] = signed_tick(samsung)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>samsung.iloc[<span class="number">50</span>:<span class="number">60</span>]</span><br><span class="line">t                          price  volume      value  signed_tick</span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48900</span>      <span class="number">10</span>     <span class="number">489000</span>         -<span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48900</span>      <span class="number">20</span>     <span class="number">978000</span>         -<span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48900</span>      <span class="number">50</span>    <span class="number">2445000</span>         -<span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>      <span class="number">69</span>    <span class="number">3377550</span>          <span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48900</span>    <span class="number">2250</span>  <span class="number">110025000</span>         -<span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48900</span>     <span class="number">148</span>    <span class="number">7237200</span>         -<span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>       <span class="number">5</span>     <span class="number">244750</span>          <span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>       <span class="number">3</span>     <span class="number">146850</span>          <span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>      <span class="number">10</span>     <span class="number">489500</span>          <span class="number">1.0</span></span><br><span class="line"><span class="number">2020</span>-03-<span class="number">25</span> 09:<span class="number">00</span>:<span class="number">26</span>+09:<span class="number">00</span>  <span class="number">48950</span>     <span class="number">300</span>   <span class="number">14685000</span>          <span class="number">1.0</span></span><br></pre></td></tr></table></figure><h2 id="2-1-Tick-imbalance-bars-TIBs"><a href="#2-1-Tick-imbalance-bars-TIBs" class="headerlink" title="2.1. Tick imbalance bars (TIBs)"></a>2.1. Tick imbalance bars (TIBs)</h2><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h3><p>Signed tick이 편향되었다는 판단은 다양한 방법으로 내릴 수 있습니다. 그 중 한 방법으로, signed tick을 누적하여 <strong>tick imbalance ($\theta_T$)</strong> 를 정의할 수 있습니다. $T$ 시점에서의 tick imbalance는 다음과 같이 정의됩니다.</p><escape>\begin{align*}\theta_T = \sum^{T}_{t=1}{b_t}\end{align*}</escape><p>그 다음으로, 현 시점에서 예상되는 다음 tick imbalance bar의 tick imbalance 값, $E_0[\theta_T]$를 구해줍니다.</p><escape>\begin{align*}E_0[\theta_T] = E_0[T](P[b_t=1] - P[b_t=-1]) = E_0[T] \cdot E_0[b_t]\end{align*}</escape><p>여기서 $E_0[T]$는 현 시점에서 예상되는 다음 bar의 크기 (틱의 개수), $E_0[b_t]$은 $b_t$의 기대값입니다. $E_0[T]$와 $E_0[b_t]$ 값을 구하는 방법 중 하나는, 이전에 추출된 tick imbalance bar들의 $T$값과 $b_t$값에 exponentially weighted moving average를 적용하여 사용하는 방법이 있습니다.</p><p>마지막으로, tick imbalance의 크기가 예상 tick imbalance를 넘어가는 순간에 bar를 정의합니다.</p><escape>\begin{align*}T^* = \underset{T}{\operatorname{argmin}}\left\{ |\theta_T|\ge \left| E_0[\theta_T] \right| \right\}\end{align*}</escape><p>Bar를 정의하는데 사용된 데이터($t \in [1,T^*]$)를 제외하고 위의 과정을 반복해주면, 전체 데이터에 대한 tick imbalance bar를 정의할 수 있습니다.</p><p>틱 데이터가 예상한 것 이상으로 불균형 할 때 $\theta_T$ 값은 커지고, 더 작은 $T$ 값으로도 $T^*$를 정의할 수 있습니다. 다르게 이야기하면, 정보의 비대칭으로 인하여 방향성이 있는 informed trading이 시장에 많이 존재 할 수록, TIB는 더 많이 생성됩니다. 따라서, TIB는 일종의 <strong>“동일한 양의 정보를 포함하는 데이터들의 묶음”</strong> 으로 생각할 수도 있겠습니다.</p><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><p>이전의 구현들은 numpy의 퍼포먼스를 끌어올리기 위해서 최대한 vectorized 연산을 활용하였습니다. TIB의 경우, bar를 나누는 기준이 되는 $E_0[\theta_T]$의 값이 bar를 추출하는 과정 중에 지속적으로 업데이트 됩니다. Iterative한 알고리즘으로 구현을 해야 할 것으로 보입니다.</p><p>아래의 코드는, 데이터 iterate를 하는 동안 연산의 횟수를 줄이는 데 초점을 맞춘 구현입니다. pandas DataFrame의 <code>loc</code>, <code>iloc</code>은 역할이 다양하여 약간의 overhead가 있습니다. (<em><a href="https://pandas.pydata.org/docs/user_guide/indexing.html#fast-scalar-value-getting-and-setting">Pandas doc</a></em>) 따라서, dataframe 외부에서 tick numbering을 해준 뒤, 한번에 column을 새로 만들어주는 방법을 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tick_imbalance_bar</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tick,</span></span><br><span class="line"><span class="params">    initial_expected_bar_size=<span class="number">10</span>,</span></span><br><span class="line"><span class="params">    initial_expected_signed_tick=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_bar_size=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_signed_tick=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    tick = tick.sort_index(ascending=<span class="literal">True</span>)</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Part 1. Tick imbalance 값을 기반으로, bar numbering(`tick_imbalance_group`)</span></span><br><span class="line">    tick_imbalance = signed_tick(tick).cumsum().values</span><br><span class="line">    tick_imbalance_group = []</span><br><span class="line">    </span><br><span class="line">    expected_bar_size = initial_expected_bar_size</span><br><span class="line">    expected_signed_tick = initial_expected_signed_tick</span><br><span class="line">    expected_tick_imbalance = expected_bar_size * expected_signed_tick</span><br><span class="line">    </span><br><span class="line">    current_group = <span class="number">1</span></span><br><span class="line">    previous_i = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tick)):</span><br><span class="line">        tick_imbalance_group.append(current_group)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(tick_imbalance[i]) &gt;= <span class="built_in">abs</span>(expected_tick_imbalance):</span><br><span class="line">            expected_bar_size = (</span><br><span class="line">                lambda_bar_size * (i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_bar_size) * expected_bar_size</span><br><span class="line">            )</span><br><span class="line">            expected_signed_tick = (</span><br><span class="line">                lambda_signed_tick * tick_imbalance[i] / (i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_signed_tick) * expected_signed_tick</span><br><span class="line">            )</span><br><span class="line">            expected_tick_imbalance = expected_bar_size * expected_signed_tick</span><br><span class="line">            </span><br><span class="line">            tick_imbalance -= tick_imbalance[i]</span><br><span class="line">            </span><br><span class="line">            previous_i = i</span><br><span class="line">            current_group += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Part 2. Bar numbering 기반으로, OHLCV bar 생성</span></span><br><span class="line">    tick[<span class="string">&#x27;tick_imbalance_group&#x27;</span>] = tick_imbalance_group</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;tick_imbalance_group&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">        </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><h2 id="2-2-Volume-x2F-Dollar-imbalance-bars-VIBs-x2F-DIBs"><a href="#2-2-Volume-x2F-Dollar-imbalance-bars-VIBs-x2F-DIBs" class="headerlink" title="2.2. Volume&#x2F;Dollar imbalance bars (VIBs&#x2F;DIBs)"></a>2.2. Volume&#x2F;Dollar imbalance bars (VIBs&#x2F;DIBs)</h2><h3 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h3><p>Tick bars의 문제점을 해결하기 위하여 volume bar와 dollar bar로 개념을 확장한 것과 같이, tick imbalance bar의 개념을 volume imbalance bar와 dollar imbalance bar로 확장할 수 있습니다. <strong>거래량 혹은 거래대금의 비대칭이 예상 수준을 넘어설 때 bar를 추출하는 방법입니다.</strong> 그 과정은 TIB와 동일합니다.</p><p>참고한 서적에서는 $b_t&#x3D;1$인 경우와 $b_t&#x3D;-1$인 경우를 따로 구분하여 계산하지만, 저는 약간 다른 방식으로 내용을 이해했습니다. 가장 먼저, 앞서서 정의했던 signed tick을 활용하여 <strong>signed volume 혹은 signed value ($c_t$)</strong> 를 정의합니다. 여기서 $v_t$는 추출하려는 bar의 종류에 따라 거래량(VIB) 혹은 거래대금(DIB) 값을 사용합니다.</p><escape>\begin{align*}c_t = b_t v_t\end{align*}</escape><p>다음으로, $T$ 시점에서의 imbalance, $\theta_T$를 아래와 같이 정의합니다. </p><escape>\begin{align*}\theta_T = \sum^{T}_{t=1}{c_t} = \sum^{T}_{t=1}{b_t v_t}\end{align*}</escape><p>그 다음으로, 현 시점에서 예상되는 다음 bar의 imbalance 값, $E_0[\theta_T]$를 구해줍니다.</p><escape>\begin{align*}E_0[\theta_T] &= E_0[T](P[b_t=1]E_0[c_t|b_t=1] + P[b_t=-1]E_0[c_t|b_t=-1]) \\              &= E_0[T]\cdot E_0[c_t]\end{align*}</escape><p>Tick imbalance bar를 계산할 때와 마찬가지로, $E_0[T]$ 값과 $E_0[c_t]$ 값은 이전 bar들의 $T$값과 $c_t$ 값에 exponential weighted moving average를 취해 근사할 수 있습니다.</p><p>마지막으로, imbalance의 크기가 예상 수치($E_0[\theta_T]$)를 넘어가는 순간에 bar를 추출합니다.</p><escape>\begin{align*}T^* = \underset{T}{\operatorname{argmin}}\left\{ |\theta_T|\ge \left| E_0[\theta_T] \right| \right\}\end{align*}</escape><p>Bar를 정의하는데 사용된 데이터($t \in [1,T^*]$)를 제외하고 위의 과정을 반복해주면, 전체 데이터에 대한 volume imbalance bar (혹은 dollar imbalance bar)를 정의할 수 있습니다.</p><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>Imbalance를 정의한 뒤, 해당 imbalance가 예상 수치를 벗어나는 경우 bar를 추출한다는 점에서 TIB와 VIB, DIB의 로직은 동일합니다. 따라서, TIB의 구현에서 <code>imbalance</code>의 값을 조절하여 DIB와 VIB를 추출할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">imbalance_bar</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="built_in">type</span>,  <span class="comment"># &#x27;tick&#x27;, &#x27;volume&#x27;, &#x27;dollar&#x27;</span></span></span><br><span class="line"><span class="params">    tick,</span></span><br><span class="line"><span class="params">    initial_expected_bar_size,</span></span><br><span class="line"><span class="params">    initial_expected_signed,</span></span><br><span class="line"><span class="params">    lambda_bar_size=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_signed=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    tick = tick.sort_index(ascending=<span class="literal">True</span>)</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Part 1. Imbalance 값을 기반으로, bar numbering(`imbalance_group`)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;tick&#x27;</span>:</span><br><span class="line">        imbalance = signed_tick(tick).cumsum().values</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;volume&#x27;</span>:</span><br><span class="line">        imbalance = (signed_tick(tick) * tick[<span class="string">&#x27;volume&#x27;</span>]).cumsum().values</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;dollar&#x27;</span>:</span><br><span class="line">        imbalance = (signed_tick(tick) * tick[<span class="string">&#x27;value&#x27;</span>]).cumsum().values</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;`type`은 [&quot;tick&quot;, &quot;volume&quot;, &quot;dollar&quot;] 중 한 가지 값을 가져야 합니다.&#x27;</span>)</span><br><span class="line">    imbalance_group = []</span><br><span class="line">    </span><br><span class="line">    expected_bar_size = initial_expected_bar_size</span><br><span class="line">    expected_signed = initial_expected_signed</span><br><span class="line">    expected_imbalance = expected_bar_size * expected_signed</span><br><span class="line">    </span><br><span class="line">    current_group = <span class="number">1</span></span><br><span class="line">    previous_i = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tick)):</span><br><span class="line">        imbalance_group.append(current_group)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(imbalance[i]) &gt;= <span class="built_in">abs</span>(expected_imbalance):</span><br><span class="line">            expected_bar_size = (</span><br><span class="line">                lambda_bar_size * (i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_bar_size) * expected_bar_size</span><br><span class="line">            )</span><br><span class="line">            expected_signed = (</span><br><span class="line">                lambda_signed * imbalance[i] / (i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_signed) * expected_signed</span><br><span class="line">            )</span><br><span class="line">            expected_imbalance = expected_bar_size * expected_signed</span><br><span class="line">            </span><br><span class="line">            previous_i = i</span><br><span class="line">            imbalance -= imbalance[i]</span><br><span class="line">            current_group += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Part 2. Bar numbering 기반으로, OHLCV bar 생성</span></span><br><span class="line">    tick[<span class="string">&#x27;imbalance_group&#x27;</span>] = imbalance_group</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;imbalance_group&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">        </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><h2 id="2-3-Tick-runs-bars-TRBs"><a href="#2-3-Tick-runs-bars-TRBs" class="headerlink" title="2.3. Tick runs bars (TRBs)"></a>2.3. Tick runs bars (TRBs)</h2><h3 id="Definition-7"><a href="#Definition-7" class="headerlink" title="Definition"></a>Definition</h3><p>앞서 살펴본 tick imbalance bar는 signed tick의 누적값을 기준으로 bar를 추출합니다. Tick runs bar는 signed tick을 하나의 값으로 누적하는 것에서 더 나아가, <strong>$b_t&#x3D;1$인 경우와 $b_t&#x3D;-1$인 경우를 따로 누적하여, 두 수치 사이의 비대칭을 기준으로 bar를 추출하는 방법</strong>입니다. 하나의 큰 거래가 호가를 밀면서 체결되거나 여러개의 작은 거래로 나뉘어져서 체결되는 경우 $b_{t&#x3D;1,…,T}$에 <strong>run</strong>(연속된 데이터 흔적)을 남기게 되는데, 이를 포착하는 방법입니다.</p><p>가장 먼저, 현재 run의 길이, $\theta_T$를 다음과 같이 정의합니다.</p><escape>\begin{align*}\theta_T = \text{max}\left\{\sum^{T}_{t|b_t=1}{b_t}, -\sum^{T}_{t|b_t=-1}{b_t} \right\}\end{align*}</escape><p>통계학에서 말하는 run은 동일한 관측값이 (끊김없이) 연속적으로 이어진 것을 의미합니다. (<em><a href="https://en.wikipedia.org/wiki/Wald%E2%80%93Wolfowitz_runs_test#Definition">Wikipedia</a></em>) 이와는 약간 다르게, 서적에서 정의한 run은 데이터의 끊김(sequence break)을 허용합니다. 즉, 여기서 말하는 “run의 길이”는 연속된 데이터의 실질적인 길이를 의미하는 것이 아니라, 일정 기간 동안 관찰된 최빈값의 빈도수를 의미합니다.</p><p>다음으로, 현 시점에서 예상되는 다음 run의 길이, $E[\theta_T]$를 구해줍니다.</p><escape>\begin{align*}E_0[\theta_T] &= E_0[T]\cdot \text{max}\left\{ P[b_t=1], P[b_t=-1] \right\} \\              &= E_0[T]\cdot \text{max}\left\{ P[b_t=1], 1-P[b_t=1] \right\}\end{align*}</escape><p>Imbalance bar와 마찬가지로, $E_0[T]$와 $P[b_t&#x3D;1]$ 값은 추정치를 사용하고, 이전 bar의 $T$, $P[b_t&#x3D;1]$(proportion of buy ticks)의 EWMA 값을 사용하는 것이 하나의 방법입니다.</p><p>이후, run의 길이가 예상되는 run의 길이를 넘어가는 순간 bar를 추출합니다.</p><escape>\begin{align*}T^* = \underset{T}{\operatorname{argmin}}\left\{ \theta_T \ge E_0[\theta_T] \right\}\end{align*}</escape><p>Bar를 정의하는데 사용된 데이터($t \in [1,T^*]$)를 제외하고 위의 과정을 반복해주면, 전체 데이터에 대한 tick run bar를 정의할 수 있습니다.</p><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><p>로직은 TIB, VIB, DIB의 구현과 동일하고, bar를 추출하는 기준(라인 33)만 다릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tick_runs_bar</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tick,</span></span><br><span class="line"><span class="params">    initial_expected_bar_size,</span></span><br><span class="line"><span class="params">    initial_buy_prob,</span></span><br><span class="line"><span class="params">    lambda_bar_size=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_buy_prob=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    tick = tick.sort_index(ascending=<span class="literal">True</span>)</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    _signed_tick = signed_tick(tick)</span><br><span class="line">    imbalance_tick_buy = _signed_tick.apply(<span class="keyword">lambda</span> v: v <span class="keyword">if</span> v&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>).cumsum()</span><br><span class="line">    imbalance_tick_sell = _signed_tick.apply(<span class="keyword">lambda</span> v: -v <span class="keyword">if</span> v&lt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>).cumsum()</span><br><span class="line">    </span><br><span class="line">    group = []</span><br><span class="line">    </span><br><span class="line">    expected_bar_size = initial_expected_bar_size</span><br><span class="line">    buy_prob = initial_buy_prob</span><br><span class="line">    expected_runs = expected_bar_size * <span class="built_in">max</span>(buy_prob, <span class="number">1</span>-buy_prob)</span><br><span class="line">    </span><br><span class="line">    current_group = <span class="number">1</span></span><br><span class="line">    previous_i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tick)):</span><br><span class="line">        group.append(current_group)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(imbalance_tick_buy[i], imbalance_tick_sell[i]) &gt;= expected_runs:</span><br><span class="line">            expected_bar_size = (</span><br><span class="line">                lambda_bar_size * (i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_bar_size) * expected_bar_size</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            buy_prob = (</span><br><span class="line">                lambda_buy_prob * imbalance_tick_buy[i]/(i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_buy_prob) * buy_prob</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            previous_i = i</span><br><span class="line">            imbalance_tick_buy -= imbalance_tick_buy[i]</span><br><span class="line">            imbalance_tick_sell -= imbalance_tick_sell[i]</span><br><span class="line">            current_group += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    tick[<span class="string">&#x27;group&#x27;</span>] = group</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;group&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">        </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><h2 id="2-4-Volume-x2F-Dollar-runs-bars-VRBs-x2F-DRBs"><a href="#2-4-Volume-x2F-Dollar-runs-bars-VRBs-x2F-DRBs" class="headerlink" title="2.4 Volume&#x2F;Dollar runs bars (VRBs&#x2F;DRBs)"></a>2.4 Volume&#x2F;Dollar runs bars (VRBs&#x2F;DRBs)</h2><h3 id="Definition-8"><a href="#Definition-8" class="headerlink" title="Definition"></a>Definition</h3><p>Tick runs bars의 개념을 확장하여, 거래량 혹은 거래대금으로 runs bars를 추출하는 방법입니다. 먼저, 거래량&#x2F;거래대금 run($\theta_T$)를 다음과 같이 정의합니다. 위와 마찬가지로, $v_t$는 추출하려는 bar의 종류에 따라 거래량(VRB) 혹은 거래대금(DRB) 값을 사용합니다.</p><escape>\begin{align*}\theta_T = \operatorname{max}\left\{ \sum^{T}_{t|b_t=1}{b_tv_t}, -\sum^{T}_{t|b_t=-1}{b_tv_t} \right\}\end{align*}</escape><p>다음으로, 현 시점에서 예상되는 다음 bar의 run 값, $E_0[\theta_T]$를 계산합니다.</p><escape>\begin{align*}E_0[\theta_t] = E_0[T]\operatorname{max}\left\{ P[b_t=1]E_0[v_t|b_t=1], (1-P[b_t=1])E_0[v_t|b_t=-1] \right\}\end{align*}</escape><p>위 수식에서 필요한 몇 가지 값들은 아래와 같습니다. (TIB, VIB, DIB, TRB에 비해 estimate 해야 하는 값들이 더 많습니다.)</p><ul><li>$E_0[T]$는 (이전 bar들의) $T$ 값의 EWMA를 사용합니다.</li><li>$P[b_t&#x3D;1]$은 (이전 bar들의) $P[b_t&#x3D;1]$(proportion of buy ticks)값들의 EWMA를 사용합니다.</li><li>$E_0[v_t|b_t&#x3D;1]$은 (이전 bar들의) 시장가 매도수량값들의 EWMA를 사용합니다.</li><li>$E_0[v_t|b_t&#x3D;-1]$은 (이전 bar들의) 시장가 매수수량값들의 EWMA를 사용합니다.</li></ul><p>마지막으로, run의 길이가 예상되는 run의 길이를 넘어가는 순간 bar를 추출합니다.</p><escape>\begin{align*}T^* = \underset{T}{\operatorname{argmin}}\left\{ \theta_T \ge E_0[\theta_T] \right\}\end{align*}</escape><p>Bar를 정의하는데 사용된 데이터($t \in [1,T^*]$)를 제외하고 위의 과정을 반복해주면, 전체 데이터에 대한 volume&#x2F;dollar run bar를 정의할 수 있습니다.</p><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><p>TIB를 VIB&#x2F;DIB로 구현을 확장한 것과 같이, TRB의 구현을 응용하여 VRB&#x2F;DRB를 아래와 같이 추출할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">volume_runs_bar</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tick,</span></span><br><span class="line"><span class="params">    initial_expected_bar_size,</span></span><br><span class="line"><span class="params">    initial_buy_prob,</span></span><br><span class="line"><span class="params">    initial_buy_volume,</span></span><br><span class="line"><span class="params">    initial_sell_volume,</span></span><br><span class="line"><span class="params">    lambda_bar_size=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_buy_prob=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_buy_volume=<span class="number">.1</span>,</span></span><br><span class="line"><span class="params">    lambda_sell_volume=<span class="number">.1</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    tick = tick.sort_index(ascending=<span class="literal">True</span>)</span><br><span class="line">    tick = tick.reset_index()</span><br><span class="line">    </span><br><span class="line">    _signed_tick = signed_tick(tick)</span><br><span class="line">    _signed_volume = _signed_tick * tick[<span class="string">&#x27;volume&#x27;</span>]</span><br><span class="line">    imbalance_tick_buy = _signed_tick.apply(<span class="keyword">lambda</span> v: v <span class="keyword">if</span> v&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>).cumsum()</span><br><span class="line">    imbalance_volume_buy = _signed_volume.apply(<span class="keyword">lambda</span> v: v <span class="keyword">if</span> v&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>).cumsum()</span><br><span class="line">    imbalance_volume_sell = _signed_volume.apply(<span class="keyword">lambda</span> v: v <span class="keyword">if</span> -v&lt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>).cumsum()</span><br><span class="line">    </span><br><span class="line">    group = []</span><br><span class="line">    </span><br><span class="line">    expected_bar_size = initial_expected_bar_size</span><br><span class="line">    buy_prob = initial_buy_prob</span><br><span class="line">    buy_volume = initial_buy_volume</span><br><span class="line">    sell_volume = initial_sell_volume</span><br><span class="line">    expected_runs = expected_bar_size * <span class="built_in">max</span>(buy_prob * buy_volume, (<span class="number">1</span>-buy_prob) * sell_volume)</span><br><span class="line">    </span><br><span class="line">    current_group = <span class="number">1</span></span><br><span class="line">    previous_i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tick)):</span><br><span class="line">        group.append(current_group)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(imbalance_volume_buy[i], imbalance_volume_sell[i]) &gt;= expected_runs:</span><br><span class="line">            expected_bar_size = (</span><br><span class="line">                lambda_bar_size * (i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_bar_size) * expected_bar_size</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            buy_prob = (</span><br><span class="line">                lambda_buy_prob * imbalance_tick_buy[i]/(i-previous_i+<span class="number">1</span>) +</span><br><span class="line">                (<span class="number">1</span>-lambda_buy_prob) * buy_prob</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            buy_volume = (</span><br><span class="line">                lambda_buy_volume * imbalance_volume_buy[i] +</span><br><span class="line">                (<span class="number">1</span>-lambda_buy_volume) * buy_volume</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            sell_volume = (</span><br><span class="line">                lambda_sell_volume * imbalance_volume_sell[i] +</span><br><span class="line">                (<span class="number">1</span>-lambda_sell_volume) * sell_volume</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            previous_i = i</span><br><span class="line">            imbalance_tick_buy -= imbalance_tick_buy[i]</span><br><span class="line">            imbalance_volume_buy -= imbalance_volume_buy[i]</span><br><span class="line">            imbalance_volume_sell -= imbalance_volume_sell[i]</span><br><span class="line">            current_group += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    tick[<span class="string">&#x27;group&#x27;</span>] = group</span><br><span class="line">    groupby = tick.groupby(<span class="string">&#x27;group&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bars = groupby[<span class="string">&#x27;price&#x27;</span>].ohlc()</span><br><span class="line">    bars[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]] = groupby[[<span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>]].<span class="built_in">sum</span>()</span><br><span class="line">    bars[<span class="string">&#x27;t&#x27;</span>] = groupby[<span class="string">&#x27;t&#x27;</span>].first()</span><br><span class="line">        </span><br><span class="line">    bars.set_index(<span class="string">&#x27;t&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bars</span><br></pre></td></tr></table></figure><hr><h1 id="3-Appendix"><a href="#3-Appendix" class="headerlink" title="3. Appendix"></a>3. Appendix</h1><h2 id="3-1-Timebar-→-Timebar"><a href="#3-1-Timebar-→-Timebar" class="headerlink" title="3.1. Timebar → Timebar"></a>3.1. Timebar → Timebar</h2><p>간혹, 하나의 timebar를 다른 단위의 timebar로 변환을 해야 할 때가 있습니다. 이 경우, <code>pandas.DataFrame.resample</code>을 통해 시계열 index를 재정렬 할 수 있습니다.</p><p>아래의 <code>timebar_1min</code> 데이터는 2021년 2월 11일 00:00부터 15일 08:40까지의 비트코인 1분봉 데이터입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timebar_1min</span><br><span class="line">                           <span class="built_in">open</span>        high  ...     volume         value</span><br><span class="line">t                                            ...                         </span><br><span class="line"><span class="number">2021</span>-02-<span class="number">11</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48384000.0</span>  <span class="number">48391000.0</span>  ...  <span class="number">20.124271</span>  <span class="number">9.732357e+08</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">11</span> <span class="number">00</span>:01:<span class="number">00</span>  <span class="number">48377000.0</span>  <span class="number">48587000.0</span>  ...  <span class="number">16.129580</span>  <span class="number">7.815445e+08</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">11</span> <span class="number">00</span>:02:<span class="number">00</span>  <span class="number">48446000.0</span>  <span class="number">48446000.0</span>  ...  <span class="number">14.955761</span>  <span class="number">7.228841e+08</span></span><br><span class="line">                         ...         ...  ...        ...           ...</span><br><span class="line"><span class="number">2021</span>-02-<span class="number">15</span> 08:<span class="number">38</span>:<span class="number">00</span>  <span class="number">52470000.0</span>  <span class="number">52620000.0</span>  ...  <span class="number">10.435710</span>  <span class="number">5.480798e+08</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">15</span> 08:<span class="number">39</span>:<span class="number">00</span>  <span class="number">52592000.0</span>  <span class="number">52626000.0</span>  ...   <span class="number">2.021345</span>  <span class="number">1.063235e+08</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">15</span> 08:<span class="number">40</span>:<span class="number">00</span>  <span class="number">52625000.0</span>  <span class="number">52627000.0</span>  ...   <span class="number">1.383658</span>  <span class="number">7.281528e+07</span></span><br><span class="line">[<span class="number">6281</span> rows x <span class="number">6</span> columns]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timebar_1min.index</span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2021-02-11 00:00:00&#x27;</span>, <span class="string">&#x27;2021-02-11 00:01:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2021-02-11 00:02:00&#x27;</span>, <span class="string">&#x27;2021-02-11 00:03:00&#x27;</span>,</span><br><span class="line">               ...</span><br><span class="line">               <span class="string">&#x27;2021-02-15 08:37:00&#x27;</span>, <span class="string">&#x27;2021-02-15 08:38:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2021-02-15 08:39:00&#x27;</span>, <span class="string">&#x27;2021-02-15 08:40:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, name=<span class="string">&#x27;t&#x27;</span>, length=<span class="number">6281</span>, freq=<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timebar_1min.columns</span><br><span class="line">Index([<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>, <span class="string">&#x27;value&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>1분봉 데이터를 60분봉 데이터로 변환하려면, 다음과 같이 resampling을 해주면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timebar_1min.resample(<span class="string">&#x27;60min&#x27;</span>).agg(&#123;  <span class="comment"># 기존의 데이터를 60분 단위로 모아서,</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;open&#x27;</span>: <span class="string">&#x27;first&#x27;</span>,  <span class="comment"># 그룹 중 가장 첫 번째 open 값을 해당 그룹의 open 값으로 사용</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;high&#x27;</span>: <span class="string">&#x27;max&#x27;</span>,    <span class="comment"># 그룹 중 가장 큰 high 값을 해당 그룹의 high 값으로 사용</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;low&#x27;</span>: <span class="string">&#x27;min&#x27;</span>,     <span class="comment"># 그룹 중 가장 작은 low 값을 해당 그룹의 low 값으로 사용</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;close&#x27;</span>: <span class="string">&#x27;last&#x27;</span>,  <span class="comment"># 그룹 중 가장 마지막 close 값을 해당 그룹의 close 값으로 사용</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;volume&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>,  <span class="comment"># 그룹 내 volume 값을 모두 더한 값을 해당 그룹의 volume 값으로 사용</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>    <span class="comment"># 그룹 내 value 값을 모두 더한 값을 해당 그룹의 value 값으로 사용</span></span><br><span class="line"><span class="meta">... </span>&#125;)</span><br><span class="line">                           <span class="built_in">open</span>        high  ...       volume         value</span><br><span class="line">t                                            ...                           </span><br><span class="line"><span class="number">2021</span>-02-<span class="number">11</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48384000.0</span>  <span class="number">48840000.0</span>  ...  <span class="number">1288.234569</span>  <span class="number">6.193043e+10</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">11</span> 01:<span class="number">00</span>:<span class="number">00</span>  <span class="number">47910000.0</span>  <span class="number">48266000.0</span>  ...   <span class="number">506.462391</span>  <span class="number">2.428122e+10</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">11</span> 02:<span class="number">00</span>:<span class="number">00</span>  <span class="number">48104000.0</span>  <span class="number">48376000.0</span>  ...   <span class="number">223.599107</span>  <span class="number">1.075957e+10</span></span><br><span class="line">                         ...         ...  ...          ...           ...</span><br><span class="line"><span class="number">2021</span>-02-<span class="number">15</span> 06:<span class="number">00</span>:<span class="number">00</span>  <span class="number">52422000.0</span>  <span class="number">52670000.0</span>  ...   <span class="number">117.880850</span>  <span class="number">6.193310e+09</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">15</span> 07:<span class="number">00</span>:<span class="number">00</span>  <span class="number">52653000.0</span>  <span class="number">52975000.0</span>  ...   <span class="number">223.672317</span>  <span class="number">1.180129e+10</span></span><br><span class="line"><span class="number">2021</span>-02-<span class="number">15</span> 08:<span class="number">00</span>:<span class="number">00</span>  <span class="number">52823000.0</span>  <span class="number">52847000.0</span>  ...   <span class="number">187.066944</span>  <span class="number">9.853452e+09</span></span><br><span class="line">[<span class="number">105</span> rows x <span class="number">6</span> columns]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-Introduction&quot;&gt;&lt;a href=&quot;#0-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0. Introduction&quot;&gt;&lt;/a&gt;0. Introduction&lt;/h1&gt;&lt;p&gt;체결 데이터(틱데이터)를 사용할 때, 데이터가 지나치게 raw해서 생기는 난감한 부분들이 많습니다. 이를 해결하기 위해 “분봉”이나 “일봉”처럼, 일정한 시간을 기준으로 체결내역을 grouping하는 전처리 방법이 가장 많이 사용되는 것 같습니다. 이러한 방법의 장단점은 무엇일까요? 혹시 다른 방법은 없을까요? 어떻게 구현을 해야 할까요?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Marcos Lopez de Prado의 저서 &lt;em&gt;Advances in Financial Machine Learning&lt;/em&gt;&lt;/strong&gt;에 위 질문들에 대한 답변이 정리가 잘 되어있습니다. &lt;strong&gt;이번 포스팅은 해당 서적의 “2.3 Financial Data Structures: Bars” 챕터를 공부하며 이해한 내용을 정리한 내용입니다.&lt;/strong&gt; 워낙 유명한 저서인지라, 책의 내용에 대한 구현을 정리해놓은 &lt;a href=&quot;https://github.com/hudson-and-thames/mlfinlab&quot;&gt;github repo&lt;/a&gt;도 있습니다. 다만, 모듈화를 위해 로직이 흩어져있어서 이해하기가 쉽지 않아, Python pandas를 사용하여 직접 구현을 해보았습니다.&lt;/p&gt;
&lt;p&gt;포스팅의 내용 혹은 코드에 개선이 필요한 경우, 피드백을 주시면 감사하겠습니다. :)&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://hwangheek.github.io/tags/Python/"/>
    
    <category term="Pandas" scheme="https://hwangheek.github.io/tags/Pandas/"/>
    
    <category term="System Trading" scheme="https://hwangheek.github.io/tags/System-Trading/"/>
    
    <category term="Advances in Financial Machine Learning" scheme="https://hwangheek.github.io/tags/Advances-in-Financial-Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>조금 더 체계적인 Python Logging</title>
    <link href="https://hwangheek.github.io/2019/python-logging/"/>
    <id>https://hwangheek.github.io/2019/python-logging/</id>
    <published>2019-03-12T13:12:28.000Z</published>
    <updated>2022-07-23T14:39:52.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Python으로 코드를 짤 때, 로그를 띄우는 방법으로 <code>print(&#39;[*] Message&#39;)</code>를 정말 많이 써 왔습니다. 군더더기 없고, 유연하고, dependency 없이 아무 위치에나 넣을 수 있다는 점이 좋았습니다. ‘좋았다’ 보다는 ‘편했다’ 혹은 ‘귀찮았다’가 더 적절한 것 같습니다. 혼자서 사용하는 프로그램을 짤 때는 exception 처리나 로그 처리에 신경을 쓰지 않아도 문제가 없었기 때문인 것 같습니다.</p><p>이러한 방법은 문제가 많이 있습니다. 중요도에 따라서 로그를 분류할 수도 없을 뿐더러, 코드를 수정하지 않는 이상 로그를 컨트롤 할 수도 없습니다. 정말로 print 되어야 하는 내용과 로그가 뒤섞여 버려서 화면이 지저분해지는 것도 문제입니다. <em>(Fang’s coding note)</em> 가끔은 조용히 프로그램을 돌리고 싶을 때도 있고, 가끔은 verbose 해지고 싶어질 때도 있잖아요?</p><img src="/images/2019-03-morpheus_logging.jpg" class="" width="500" title="Better Logging"><p><strong>Python에서는 <code>logging</code> 모듈을 기본적으로 제공합니다.</strong> 이제 <code>print(&#39;[*] ...&#39;)</code>만 사용하지 말고, <code>logging</code> 모듈을 통해 멋지고 깔끔한 로깅을 해봅시다. 이번 포스트를 통해 Python에서 제공하는 <code>logging</code> 모듈을 어떻게 사용하는지 알아보도록 하겠습니다. 또한, ‘좋은 로그 처리 방법’이 어떤 성질을 지니고 있을 지에 대한 고민도 해보겠습니다.</p><span id="more"></span><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>Python Official Document, <a href="https://docs.python.org/3/library/logging.html"><code>logging</code></a>, <a href="https://docs.python.org/3.7/howto/logging.html">Logging HOWTO</a>, <a href="https://docs.python.org/3.7/howto/logging-cookbook.html">Logging Cookbook</a></li><li>Fang’s coding note (2012), <a href="https://fangpenlin.com/posts/2012/08/26/good-logging-practice-in-python/">Good logging practice in Python</a></li><li>이승현 (2017), <a href="https://hamait.tistory.com/880">파이썬 로깅의 모든것</a></li></ul><!-- https://stackoverflow.com/questions/4577376/should-i-log-before-or-after-an-operation --><hr><h1 id="Step-1-간단하게-로그-생성해보기"><a href="#Step-1-간단하게-로그-생성해보기" class="headerlink" title="Step 1 : 간단하게 로그 생성해보기"></a>Step 1 : 간단하게 로그 생성해보기</h1><h2 id="1-1-Log-Level-로그의-‘심각한-정도’"><a href="#1-1-Log-Level-로그의-‘심각한-정도’" class="headerlink" title="1-1. Log Level : 로그의 ‘심각한 정도’"></a>1-1. Log Level : 로그의 ‘심각한 정도’</h2><p>들어가기에 앞서서, <strong>로그 레벨</strong>에 대하여 짚고 넘어갑시다. 로그는 <strong>중요도에 따라 서로 다른 레벨을 가지게 되고</strong>, 이 중요도에 따라 로그를 관리할 수 있습니다. 아래는 <a href="https://docs.python.org/3.7/howto/logging.html#when-to-use-logging">Logging HOWTO</a>에 소개된 로그의 각 레벨과 설명입니다.</p><table><thead><tr><th align="center">Level</th><th align="center">Value</th><th align="center">When to use</th></tr></thead><tbody><tr><td align="center"><code>DEBUG</code></td><td align="center">10</td><td align="center">(주로 문제 해결을 할 때 필요한) 자세한 정보.</td></tr><tr><td align="center"><code>INFO</code></td><td align="center">20</td><td align="center">작업이 정상적으로 작동하고 있다는 확인 메시지.</td></tr><tr><td align="center"><code>WARNING</code></td><td align="center">30</td><td align="center">예상하지 못한 일이 발생하거나, 발생 가능한 문제점을 명시. (e.g. ‘disk space low’) 작업은 정상적으로 진행.</td></tr><tr><td align="center"><code>ERROR</code></td><td align="center">40</td><td align="center">프로그램이 함수를 실행하지 못 할 정도의 심각한 문제.</td></tr><tr><td align="center"><code>CRITICAL</code></td><td align="center">50</td><td align="center">프로그램이 동작할 수 없을 정도의 심각한 문제.</td></tr></tbody></table><p>Python의 기본 logging 시스템의 레벨은 <code>WARNING</code>으로 설정되어 있습니다. 따라서 특별한 설정을 하지 않을 경우, <code>WARNING</code> 레벨과 이보다 더 심각한 레벨의 로그만 처리됩니다.</p><p>다음은 <a href="https://docs.python.org/3.7/howto/logging.html#when-to-use-logging">Logging HOWTO</a>에 소개된 상황에 따른 가장 적합한 로깅 방법입니다.</p><table><thead><tr><th align="center">상황</th><th align="center">방법</th></tr></thead><tbody><tr><td align="center">일반적인 console 출력</td><td align="center"><code>print()</code></td></tr><tr><td align="center">프로그램의 실행 중 발생하는 정상적인 이벤트 알림</td><td align="center"><code>logging.info()</code><br>(진단 등을 위한) 자세한 수준의 로그인 경우에는 <code>logging.debug()</code></td></tr><tr><td align="center">런타임 중 발생한 이벤트와 관련하여 경고</td><td align="center">사용자가 프로그램을 수정해서 문제를 해결할 수 있는 경우 <code>warnings.warn()</code><br>사용자가 처리할 수 있는 문제가 아닌 경우 <code>logging.warning()</code></td></tr><tr><td align="center">런타임 중 발생한 이벤트와 관련한 에러</td><td align="center">예외 처리 (<code>raise Exception</code>)</td></tr><tr><td align="center">발생한 예외를 suppress하고 raise 하지 않은 경우 (e.g. long-running 서버 프로세스에서 에러 발생 시)</td><td align="center"><code>logging.error()</code>, <code>logging.exception()</code>, <code>logging.critical()</code></td></tr></tbody></table><p>이제 본격적으로, 각 레벨의 로그를 어떻게 생성할 수 있는지 알아봅시다.</p><h2 id="1-2-Root-Logger를-이용하여-로그-생성하기"><a href="#1-2-Root-Logger를-이용하여-로그-생성하기" class="headerlink" title="1-2. Root Logger를 이용하여 로그 생성하기"></a>1-2. Root Logger를 이용하여 로그 생성하기</h2><p>가장 간단하게 로그를 생성하는 법은, <strong>module-level로 정의되어 있는 root logger를 사용하는 방법</strong>입니다. 아래와 같이 로그를 생성할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.warning(<span class="string">&#x27;This is a warning message&#x27;</span>)</span><br><span class="line"><span class="comment"># 아래와 같은 메시지가 콘솔에 출력됩니다</span></span><br><span class="line"><span class="comment"># WARNING:root:This is a warning message</span></span><br><span class="line"></span><br><span class="line">logging.info(<span class="string">&#x27;This is an info message&#x27;</span>)</span><br><span class="line"><span class="comment"># 아무 것도 프린트 되지 않습니다</span></span><br></pre></td></tr></table></figure><p><code>WARNING</code> 로그는 출력이 되었지만, <code>INFO</code> 로그는 아무것도 출력이 되지 않습니다. 이는 <strong>root logger의 기본 level이 <code>WARNING</code> 수준으로 설정되어 있어서, 해당 수준 이상의 로그만 처리되기 때문입니다.</strong> Logger가 처리하는 로그의 레벨을 조정하는 방법은 아래와 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line">logging.info(<span class="string">&#x27;This is an info message&#x27;</span>)</span><br><span class="line"><span class="comment"># 아래와 같은 메시지가 출력됩니다!</span></span><br><span class="line"><span class="comment"># INFO:root:This is an info message</span></span><br></pre></td></tr></table></figure><p>콘솔로 출력이 되는 로그를 다음과 같은 방법으로 파일에 저장할 수도 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;dummy.log&#x27;</span>, level=logging.INFO)</span><br><span class="line">logging.debug(<span class="string">&#x27;this is a debug&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;this is an info&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;this is a warning&#x27;</span>)</span><br></pre></td></tr></table></figure><p>위를 실행할 경우, <code>dummy.log</code> 파일에 다음과 같이 로그가 저장됩니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO:root:this is an info</span><br><span class="line">WARNING:root:this is a warning</span><br></pre></td></tr></table></figure><p>이렇게 설정을 할 경우, 콘솔에는 로그 메시지가 출력되지 않습니다. <code>basicConfig</code>를 여러번 실행해도 가장 처음 호출된 설정만 유효하고, 나머지는 설정이 적용되지 않습니다. <strong>Root logger에 이미 handler가 설정 되어 있다면 <code>basicConfig</code>는 아무런 처리도 하지 않습니다.</strong> 여러개의 handler를 등록하고 싶은 경우 <code>handlers</code> 인자로 전달하는 방법이 있지만, 가장 처음의 설정만 유효하다는 점은 변함이 없습니다. 하나의 logger에서 발생한 로그를 여러 handler가 처리하도록 설정하는 방법은 다음 step에서 살펴보도록 합시다.</p><p>출력되는 로그를 다음과 같이 formatting 할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">  <span class="built_in">format</span> = <span class="string">&#x27;%(asctime)s:%(levelname)s:%(message)s&#x27;</span>,</span><br><span class="line">  datefmt = <span class="string">&#x27;%m/%d/%Y %I:%M:%S %p&#x27;</span>,</span><br><span class="line">  level = logging.DEBUG</span><br><span class="line">)</span><br><span class="line">logging.debug(<span class="string">&#x27;This is a formatted debug message&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 03/12/2019 05:20:12 PM:DE<span class="doctag">BUG:</span>This is a formatted debug message</span></span><br></pre></td></tr></table></figure><p><code>format</code>에 사용되는 속성들은 <a href="https://docs.python.org/3.7/library/logging.html#logrecord-attributes">document (LogRecord attributes)</a>에서, <code>datefmt</code>에 사용되는 속성들은 <a href="https://docs.python.org/3.7/library/time.html#time.strftime">document (<code>time.strftime(...)</code>)</a>에서 확인할 수 있습니다.</p><hr><h1 id="Step-2-역할-분담하기"><a href="#Step-2-역할-분담하기" class="headerlink" title="Step 2 : 역할 분담하기"></a>Step 2 : 역할 분담하기</h1><p>로깅 시스템은 다음과 같은 구성요소들로 이루어져 있습니다.</p><ul><li><strong>Loggers</strong> : 어플리케이션 코드가 직접 사용할 수 있는 인터페이스를 제공합니다.</li><li><strong>Handlers</strong> : Loggers에 의해 생성된 LogRecord를 처리하여 적절한 위치로 보냅니다.</li><li><strong>Filters</strong> : 출력되어야 하는 로그를 필터링합니다.</li><li><strong>Formatters</strong> : LogRecord의 출력 형태를 지정합니다.</li></ul><p>로그 이벤트는 <code>LogRecord</code> 형태로 Loggers에서부터 Handlers, Formatters 순서로 전달됩니다. 자세한 순서는 <a href="https://docs.python.org/3.7/howto/logging.html#logging-flow">document (Logging Flow)</a>에 포함된 아래의 flow chart와 같습니다.</p><p><img src="/images/2019-03-logging_flow.png" alt="Logging Flowchart"></p><h2 id="2-1-Loggers"><a href="#2-1-Loggers" class="headerlink" title="2-1. Loggers"></a>2-1. Loggers</h2><p>Logger는 세가지 주요 역할을 합니다.</p><ol><li>로그를 생성할 수 있는 method를 제공해줍니다. (<code>Logger.debug()</code>, <code>Logger.info()</code>, …)</li><li>로그 레벨과 Logger에 적용된 filter를 바탕으로 처리해야 할 메시지를 판단합니다.</li><li>적절한 Handler들에게 로그 메시지에 부가정보가 더해진 <code>LogRecord</code> 인스턴스를 전달해줍니다.</li></ol><p>Logger 오브젝트는 <code>logging.getLogger(name)</code> method를 통해 사용할 수 있습니다. 이와 관련한 몇 가지 특징을 살펴보겠습니다.</p><ul><li><code>name</code>이 주어진 경우, 해당 이름에 해당하는 logger를, <code>name</code>이 주어지지 않은 경우 root logger를 전달받습니다.</li><li><code>name</code>은 마침표(<code>.</code>)로 구분되는 계층구조를 가지고 있습니다. 예를 들어, <code>getLogger(&#39;foo.bar&#39;)</code>는 <code>getLogger(&#39;foo&#39;)</code>의 자식 logger를 반환합니다.</li><li><strong>Logger의 레벨이 정해지지 않은 경우 (<code>logger.setLevel(...)</code>을 설정해주지 않은 경우), 자신의 부모 logger의 레벨을 사용합니다.</strong> 부모의 로그 레벨이 정해지지 않은 경우, 그 부모의 로그 레벨을 참조하는 식으로 반복됩니다. Root logger는 항상 로그 레벨이 설정되어있습니다. (기본값 <code>WARNING</code>)</li><li><strong>자식 logger는 메시지를 자기 부모 logger의 handler에게 propagate합니다.</strong> 따라서, 부모 logger에 handler가 설정되어 있는 경우라면, 자식 logger에서 handler를 다시 설정해야 하는 중복 업무를 줄일 수 있습니다. (<code>Logger.propagate = False</code>로 설정해줌으로써, propagation을 막을 수 있습니다.)</li></ul><p>로깅 전략에 따라서 다양한 범위를 커버하는 Logger를 선언할 수 있습니다. 아래는 이승현님의 게시글 <a href="https://hamait.tistory.com/880">파이썬 로깅의 모든것</a>에서 소개하는 ‘로거를 만드는 대표적인 범위’에 대한 내용입니다.</p><ul><li><strong>Module-wise</strong> : Python에서는 하나의 파일이 하나의 모듈입니다. 따라서, 파일의 제일 위쪽에서 모듈명(<code>__name__</code>)으로 Logger를 만드는 방법이 있습니다.</li><li><strong>Instance-wise</strong> : <code>__init__()</code> method 내에서 Logger를 생성하는 방법으로, 각 인스턴스마다 고유한 Logger를 가지게 됩니다.</li><li><strong>Class-wise</strong> : <code>__class__.__qualname__</code>에 해당하는 Logger를 생성하는 방법입니다. 클래스별로 고유한 Logger를 가지게 됩니다.</li><li><strong>Function-wise</strong> : 함수 내에서 Logger를 생성할 수도 있습니다. (e.g. <code>main()</code>)</li></ul><p>생성된 <code>Logger</code>를 설정하는 주요 method들은 다음과 같습니다.</p><ul><li><strong><code>Logger.setLevel()</code></strong> : 처리할 메시지의 최소 레벨을 설정합니다. 만약, <code>logging.INFO</code> 값을 설정하면, <code>DEBUG</code> 레벨의 로그는 무시됩니다.</li><li><strong><code>Logger.addHandler()</code></strong>, <strong><code>Logger.removeHandler()</code></strong> : Handler 오브젝트를 추가하고 제거합니다. Handler가 없는 경우도 있고, 여러개의 Handler가 하나의 Logger에 추가되는 경우도 있습니다.</li><li><strong><code>Logger.addFilter()</code></strong>, <strong><code>Logger.removeFilter()</code></strong> : Filter 오브젝트를 추가하고 제거합니다.</li></ul><p>로그를 생성하는 method들은 다음과 같습니다.</p><ul><li><strong><code>Logger.debug()</code></strong>, <strong><code>Logger.info()</code></strong>, <strong><code>Logger.warning()</code></strong>, <strong><code>Logger.error()</code></strong>, <strong><code>Logger.critical()</code></strong></li><li><strong><code>Logger.exception()</code></strong> : Stack Trace 정보가 담긴 <code>ERROR</code> 레벨의 로그를 발생시킵니다. Exception handler 안에서만 사용해야합니다.</li><li><strong><code>Logger.log()</code></strong> : 로그 레벨을 인자로 전달할 수 있습니다.</li></ul><h2 id="2-2-Handlers"><a href="#2-2-Handlers" class="headerlink" title="2-2. Handlers"></a>2-2. Handlers</h2><p>Handler는 로그 메시지를 출력하는 역할을 합니다. <a href="https://docs.python.org/3.7/howto/logging.html#useful-handlers">Useful Handlers</a>에서 Handler의 종류를 확인할 수 있습니다.</p><p>Handler를 설정하는 method는 다음과 같습니다.</p><ul><li><strong>Handler.setLevel()</strong> : 처리할 메시지의 최소 레벨을 설정합니다. Logger의 설정 레벨과 다를 수 있습니다. Logger에서는 통과가 된 로그 메시지가 Handler에서 filtering 될 수 있습니다.</li><li><strong>Handler.setFormatter()</strong> : Handler가 사용할 formatter를 설정합니다.</li><li><strong>Handler.addFilter()</strong>, <strong>Handler.removeFilter()</strong> : Filter 오브젝트를 추가하고 제거합니다.</li></ul><p>몇 가지 예시를 살펴봅시다. 스트림으로 로그를 출력하는 <code>StreamHandler</code>는 다음과 같이 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">stream_handler = logging.StreamHandler()</span><br><span class="line">logger.addHandler(stream_handler)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&#x27;This is an INFO message&#x27;</span>)</span><br><span class="line"><span class="comment"># This is an INFO message</span></span><br></pre></td></tr></table></figure><p>파일로 로그를 출력하는 <code>FileHandler</code>는 다음과 같이 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&#x27;dummy.log&#x27;</span>)</span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&#x27;This is an INFO message. Hello dummy!&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-Formatters"><a href="#2-3-Formatters" class="headerlink" title="2-3. Formatters"></a>2-3. Formatters</h2><p>Formatter는 최종적으로 출력 될 로그 메시지의 formatting에 관여합니다. Formatter는 다음과 같이 생성할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.Formatter(</span><br><span class="line">  fmt = <span class="literal">None</span>, <span class="comment"># 메시지 출력 형태. None일 경우 raw 메시지를 출력.</span></span><br><span class="line">  datefmt = <span class="literal">None</span>, <span class="comment"># 날짜 출력 형태. None일 경우 &#x27;%Y-%m-%d %H:%M:%S&#x27;.</span></span><br><span class="line">  style = <span class="string">&#x27;%&#x27;</span> <span class="comment"># &#x27;%&#x27;, &#x27;&#123;&#x27;, &#x27;$&#x27; 중 하나. `fmt`의 style을 결정.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>logging.basicConfig</code>와 마찬가지로, <code>fmt</code>에 사용되는 속성들은 <a href="https://docs.python.org/3.7/library/logging.html#logrecord-attributes">document (LogRecord attributes)</a>에서, <code>datefmt</code>에 사용되는 속성들은 <a href="https://docs.python.org/3.7/library/time.html#time.strftime">document (<code>time.strftime(...)</code>)</a>에서 확인할 수 있습니다.</p><h2 id="2-4-Putting-all-together"><a href="#2-4-Putting-all-together" class="headerlink" title="2-4. Putting all together"></a>2-4. Putting all together</h2><p>좋습니다! 앞서 살펴본 내용들을 응용하여 간단한 로깅 시스템을 만들어 보기로 합시다. 시스템의 요구사항은 다음과 같습니다.</p><ul><li><code>INFO</code> 레벨 이상의 로그를 콘솔에 출력합니다.</li><li>모든 레벨의 로그를 <code>debug.log</code>에 저장합니다.</li><li><code>ERROR</code> 이상의 로그를 <code>error.log</code>에 저장합니다.</li><li>모든 Exception을 suppress하고, stacktrace를 <code>error.log</code>에 저장합니다.</li><li>로그가 발생한 시간과 로그레벨, 모듈명이 명시되어야합니다.</li></ul><p>아래는 해당 로그 시스템을 구현한 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.DEBUG) <span class="comment"># 모든 레벨의 로그를 Handler들에게 전달해야 합니다.</span></span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s:%(module)s:%(levelname)s:%(message)s&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO 레벨 이상의 로그를 콘솔에 출력하는 Handler</span></span><br><span class="line">console_handler = logging.StreamHandler()</span><br><span class="line">console_handler.setLevel(logging.INFO)</span><br><span class="line">console_handler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(console_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DEBUG 레벨 이상의 로그를 `debug.log`에 출력하는 Handler</span></span><br><span class="line">file_debug_handler = logging.FileHandler(<span class="string">&#x27;debug.log&#x27;</span>)</span><br><span class="line">file_debug_handler.setLevel(logging.DEBUG)</span><br><span class="line">file_debug_handler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(file_debug_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ERROR 레벨 이상의 로그를 `error.log`에 출력하는 Handler</span></span><br><span class="line">file_error_handler = logging.FileHandler(<span class="string">&#x27;error.log&#x27;</span>)</span><br><span class="line">file_error_handler.setLevel(logging.ERROR)</span><br><span class="line">file_error_handler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(file_error_handler)</span><br></pre></td></tr></table></figure><hr><h1 id="Step-3-실제로-사용해보기"><a href="#Step-3-실제로-사용해보기" class="headerlink" title="Step 3 : 실제로 사용해보기"></a>Step 3 : 실제로 사용해보기</h1><h2 id="3-1-Logging-Configuration-File-in-JSON-or-YAML"><a href="#3-1-Logging-Configuration-File-in-JSON-or-YAML" class="headerlink" title="3-1. Logging Configuration File in JSON or YAML"></a>3-1. Logging Configuration File in JSON or YAML</h2><p>한번 사용된 Logger 설정을 다른 모듈에서 재사용하고 싶은 경우 어떻게 할까요? <strong>Logger 설정을 <code>dict</code> 형태를 통해 로드할 수 있습니다.</strong> 따라서, <strong>JSON 혹은 YAML 형태로 Logger 설정을 저장&#x2F;관리하고, 필요시에 <code>dict</code>로 로드하여 설정을 적용할 수 있습니다.</strong> 한 예시로, (2-4)의 로깅 시스템을 구축하는 JSON 파일을 아래와 같이 나타낼 수 있습니다.</p><figure class="highlight json"><figcaption><span>logger.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;disable_existing_loggers&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;formatters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;basic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%(asctime)s:%(module)s:%(levelname)s:%(message)s&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;datefmt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;handlers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logging.StreamHandler&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file_debug&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logging.FileHandler&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug.log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file_error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logging.FileHandler&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ERROR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error.log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;loggers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;__main__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;handlers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;console&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file_debug&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file_error&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;propagate&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>위의 JSON 파일을 다음과 같이 Logger 설정에 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">config = json.load(<span class="built_in">open</span>(<span class="string">&#x27;./logger.json&#x27;</span>))</span><br><span class="line">logging.config.dictConfig(config)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure><p>설정 파일에 특별한 점은 없습니다… 만, <code>disable_existing_loggers</code> 옵션은 뭘까요? <strong><code>logging.fileConfig()</code> 혹은 <code>logging.dictConfig()</code>를 호출할 경우, 기존에 존재하는 logger들이 전부 비활성화됩니다.</strong> 이를 방지하기 위하여, 해당 함수 호출 시에 <strong><code>disable_existing_loggers</code>을 <code>False</code>로 설정</strong>하는 것입니다.</p><h2 id="3-2-Slack-Bot으로-로그-전송하기"><a href="#3-2-Slack-Bot으로-로그-전송하기" class="headerlink" title="3-2. Slack Bot으로 로그 전송하기"></a>3-2. Slack Bot으로 로그 전송하기</h2><p>Slack의 Web API를 사용하면 bot을 제어할 수 있습니다. Bot 생성 후 발급받은 토큰만 있으면, <a href="https://api.slack.com/methods/chat.postMessage">다음</a>과 같이 <code>x-www-form-urlencoded</code> 형태나 <code>json</code> 형태의 HTTP 요청을 통해 메시지를 게시할 수 있습니다.</p><p>Python logging 모듈에서 기본적으로 <a href="https://docs.python.org/ko/3/library/logging.handlers.html#httphandler"><code>HTTPHandler</code>를 제공합니다</a>. Logger에 의해 생성된 <code>LogRecord</code>가 <code>HTTPHandler</code>에게 전달되면, <code>mapLogRecord</code> 함수를 통해 메시지가 <code>dict</code> 형태로 전처리됩니다. 특별히 override 하지 않은 경우, <code>record.__dict__</code>을 반환합니다. 이렇게 전처리 된 <code>dict</code>의 key-value pair를 <code>emit</code> 함수가 URL encoding하여 전송합니다.</p><p><code>HTTPHandler</code>의 <code>mapLogRecord</code>를 적절히 overriding하면, slack bot으로 로그를 전달할 수 있는 <code>SlackHandler</code>를 아래와 같이 구현할 수 있습니다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"></span><br><span class="line">SLACK_TOKEN = <span class="string">&#x27;xoxb-YOUR_BOT_TOKEN-COMES_HERE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SlackHandler</span>(logging.handlers.HTTPHandler):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, token, channel=<span class="string">&#x27;#general&#x27;</span>, emoji=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__(host=<span class="string">&#x27;slack.com&#x27;</span>, url=<span class="string">&#x27;/api/chat.postMessage&#x27;</span>, secure=<span class="literal">True</span>)</span><br><span class="line">    self.token = token</span><br><span class="line">    self.channel = channel</span><br><span class="line">    self.emoji = emoji</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">mapLogRecord</span>(<span class="params">self, record</span>):</span><br><span class="line">    <span class="keyword">if</span> self.formatter <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># Formatter가 설정되지 않은 경우</span></span><br><span class="line">      text = record.msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      text = self.formatter.<span class="built_in">format</span>(record)</span><br><span class="line">    </span><br><span class="line">    emoji = (</span><br><span class="line">      <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> self.emoji == <span class="literal">False</span> <span class="keyword">else</span></span><br><span class="line">      <span class="string">&#x27;:bug:&#x27;</span> <span class="keyword">if</span> record.levelname == <span class="string">&#x27;DEBUG&#x27;</span> <span class="keyword">else</span></span><br><span class="line">      <span class="string">&#x27;:pencil2:&#x27;</span> <span class="keyword">if</span> record.levelname == <span class="string">&#x27;INFO&#x27;</span> <span class="keyword">else</span></span><br><span class="line">      <span class="string">&#x27;:warning:&#x27;</span> <span class="keyword">if</span> record.levelname == <span class="string">&#x27;WARNING&#x27;</span> <span class="keyword">else</span></span><br><span class="line">      <span class="string">&#x27;:no_entry:&#x27;</span> <span class="keyword">if</span> record.levelname == <span class="string">&#x27;ERROR&#x27;</span> <span class="keyword">else</span></span><br><span class="line">      <span class="string">&#x27;:rotating_light:&#x27;</span> <span class="keyword">if</span> record.levelname == <span class="string">&#x27;CRITICAL&#x27;</span> <span class="keyword">else</span></span><br><span class="line">      <span class="string">&#x27;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="string">&#x27;token&#x27;</span>: self.token,</span><br><span class="line">      <span class="string">&#x27;channel&#x27;</span>: self.channel,</span><br><span class="line">      <span class="string">&#x27;text&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;emoji&#125;</span> <span class="subst">&#123;text&#125;</span>&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;as_user&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(</span><br><span class="line">  fmt=<span class="string">&#x27;%(asctime)s *%(module)s* : %(message)s&#x27;</span>,</span><br><span class="line">  datefmt=<span class="string">&#x27;%H:%M:%S&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">slack_handler = SlackHandler(SLACK_TOKEN)</span><br><span class="line">slack_handler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(slack_handler)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;디버깅 로그입니다.&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;일반 로그입니다.&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;경고 로그입니다.&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;에러 로그입니다.&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  logger.exception(<span class="string">&#x27;예외처리 로그입니다.&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>TOKEN</code>에 slack에서 발급받은 bot의 토큰을 입력한 뒤 위의 코드를 실행하면, slack에서 bot이 로그를 출력하는 모습을 볼 수 있습니다.</p><p><img src="/images/2019-03-python-logging-slack.png" alt="실행 결과"></p><p>이모지와 <a href="https://api.slack.com/reference/surfaces/formatting"><code>mrkdwn</code> 포맷</a>을 사용하여, 제 취향이 듬뿍 담긴 로거를 만들었습니다. <code>mapLogRecord</code> method를 다듬어서, slack에 출력되는 메시지의 스타일을 커스터마이징 할 수 있겠습니다.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Python으로 코드를 짤 때, 로그를 띄우는 방법으로 &lt;code&gt;print(&amp;#39;[*] Message&amp;#39;)&lt;/code&gt;를 정말 많이 써 왔습니다. 군더더기 없고, 유연하고, dependency 없이 아무 위치에나 넣을 수 있다는 점이 좋았습니다. ‘좋았다’ 보다는 ‘편했다’ 혹은 ‘귀찮았다’가 더 적절한 것 같습니다. 혼자서 사용하는 프로그램을 짤 때는 exception 처리나 로그 처리에 신경을 쓰지 않아도 문제가 없었기 때문인 것 같습니다.&lt;/p&gt;
&lt;p&gt;이러한 방법은 문제가 많이 있습니다. 중요도에 따라서 로그를 분류할 수도 없을 뿐더러, 코드를 수정하지 않는 이상 로그를 컨트롤 할 수도 없습니다. 정말로 print 되어야 하는 내용과 로그가 뒤섞여 버려서 화면이 지저분해지는 것도 문제입니다. &lt;em&gt;(Fang’s coding note)&lt;/em&gt; 가끔은 조용히 프로그램을 돌리고 싶을 때도 있고, 가끔은 verbose 해지고 싶어질 때도 있잖아요?&lt;/p&gt;
&lt;img src=&quot;/images/2019-03-morpheus_logging.jpg&quot; class=&quot;&quot; width=&quot;500&quot; title=&quot;Better Logging&quot;&gt;

&lt;p&gt;&lt;strong&gt;Python에서는 &lt;code&gt;logging&lt;/code&gt; 모듈을 기본적으로 제공합니다.&lt;/strong&gt; 이제 &lt;code&gt;print(&amp;#39;[*] ...&amp;#39;)&lt;/code&gt;만 사용하지 말고, &lt;code&gt;logging&lt;/code&gt; 모듈을 통해 멋지고 깔끔한 로깅을 해봅시다. 이번 포스트를 통해 Python에서 제공하는 &lt;code&gt;logging&lt;/code&gt; 모듈을 어떻게 사용하는지 알아보도록 하겠습니다. 또한, ‘좋은 로그 처리 방법’이 어떤 성질을 지니고 있을 지에 대한 고민도 해보겠습니다.&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hwangheek.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://hwangheek.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>비동기적으로 Python 다루기</title>
    <link href="https://hwangheek.github.io/2019/asynchronous-python/"/>
    <id>https://hwangheek.github.io/2019/asynchronous-python/</id>
    <published>2019-02-04T21:05:38.000Z</published>
    <updated>2022-08-08T05:56:40.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-안녕-비동기"><a href="#0-안녕-비동기" class="headerlink" title="0. 안녕, 비동기!"></a>0. 안녕, 비동기!</h1><p>Python으로 동시다발적 HTTP 요청을 보내는 작업을 해야할 필요가 생겼습니다. Python 3에서 asynchronous한 작업을 처리하기가 수월해졌다는 이야기를 어디서 들은 것 같아서 구글링을 간단히 해봤습니다…만 내용들이 이해하기가 쉽지 않았습니다. 이와 관련된 수 많은 용어들의 정의와 그 범위가 사람들마다 미묘하게 달랐기 때문입니다. 뿐만 아니라, ‘asynchronous’라는 용어 자체를 듣기만 해도 뭔가 어렵고 복잡하고 막연하게 두려운 느낌도 듭니다.</p><img src="/images/2019-02-why_so_async.png" class="" width="500" title="Async Everywhere"><p>하루 날을 잡고 asynchronous python과 관련된 자료들을 왕창 읽어보았습니다. 이 글은 키워드 <strong>generator, coroutine, asyncio</strong>와 신택스 <strong><code>yield</code>, <code>yield from</code>, <code>async</code>, <code>await</code></strong> 에 대한 이해가 없던 제가, 나름대로 이해를 하는 과정을 기록한 것입니다. <strong>혹시나 제가 잘못 이해하고 있는 부분이 있으면 말씀해주시면 감사하겠습니다</strong>.</p><span id="more"></span><h1 id="1-선지자들의-기록"><a href="#1-선지자들의-기록" class="headerlink" title="1. 선지자들의 기록"></a>1. 선지자들의 기록</h1><p>각 단계를 작성하기 위하여 다음과 같은 자료들을 참고하였습니다.</p><ul><li><strong>전반적인 내용과 흐름</strong><ul><li>Masnun (2015) <em><a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html" title="" target="">Python: Generators, Coroutines, Native coroutines and async&#x2F;await</a></em></li></ul></li><li><strong>Generator</strong><ul><li>Syed Komail Abbas (2017) <em><a href="https://hackernoon.com/the-magic-behind-python-generator-functions-bc8eeea54220" title="" target="">The Magic Behind Python Generator Functions</a></em></li></ul></li><li><strong>Coroutine</strong><ul><li>Bharel, Brad Solomon (2018) <em><a href="https://stackoverflow.com/a/51116910" title="" target="">How does asyncio actually work?</a></em></li><li>Moura, A. L. D., &amp; Ierusalimschy, R. (2004) <em><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.58.4017&rep=rep1&type=pdf" title="" target="">Revisiting coroutines</a></em></li><li>MisterMiyagi (2018) <em><a href="https://stackoverflow.com/a/51177895" title="" target="">Talking about async&#x2F;await and asyncio is not the same thing</a></em></li><li>Brett Cannon (2016) <em><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" title="" target="">How the heck does async&#x2F;await work in Python 3.5?</a></em></li></ul></li><li><strong>Concurrency와 Parallelism</strong><ul><li>ThomasWouters (2017) <em><a href="https://wiki.python.org/moin/GlobalInterpreterLock" title="" target="">GlobalInterpreterLock</a></em></li><li>Skrew Everything (2018) <em><a href="https://medium.com/from-the-scratch/dont-be-confused-between-concurrency-and-parallelism-eac8e703943a" title="" target="">Don&#39;t be confused between Concurrency and Parallelism</a></em></li></ul></li><li><strong>More about <code>async</code>, <code>await</code> and <code>asyncio</code></strong><ul><li><a href="https://docs.python.org/3/library/asyncio-task.html">Python Docs ‘Coroutines and Tasks’</a></li><li>Jinsu Kim (2017) <em><a href="https://item4.github.io/2017-11-26/Asynchronous-HTTP-Request-with-aiohttp/" title="" target="">aiohttp로 하는 비동기 HTTP 요청</a></em></li></ul></li><li><strong>Other References</strong><ul><li>YongSung Lee (2018) <em><a href="https://blog.humminglab.io/python-coroutine-programming-1/" title="" target="">Python 비동기 프로그래밍 제대로 이해하기</a></em></li><li>Nick Humrich (2016) <em><a href="https://hackernoon.com/asynchronous-python-45df84b82434" title="" target="">Asynchronous Python - Await the Future</a></em></li><li>Scott Robinson (2015) <em><a href="https://stackabuse.com/python-async-await-tutorial/" title="" target="">Python async&#x2F;await Tutorial</a></em></li><li>불곰 (2017) <em><a href="https://brownbears.tistory.com/237" title="" target="">많은 함수를 동시에 실행하려면 코루틴을 고려</a></em></li><li>Brad Solomon (2019) <em><a href="https://realpython.com/async-io-python/" title="" target="">Async IO in Python: A Complete Walkthrough</a></em></li><li>Miguel Grinberg (2017) <em><a href="https://www.youtube.com/watch?v=iG6fr81xHKA" title="" target="">Asynchronous Python for the Complete Beginner (PyCon 2017)</a></em></li></ul></li></ul><hr><h1 id="2-Generator"><a href="#2-Generator" class="headerlink" title="2. Generator"></a>2. Generator</h1><p>우리가 흔히 알고있는 Python의 함수, 즉 <code>def sth_familiar_with(): ...</code>과 같이 정의된 함수를 호출할 경우, 해당 함수의 시작부터 끝(혹은 <code>return</code>을 만날때)까지 진행이 됩니다. 그 뒤에 stack frame은 소멸되므로, 이 함수를 다시 호출할 경우 함수는 처음부터 다시 실행이 됩니다.</p><p>Generator는 약간 다릅니다. 결과물을 그때그때 생성해내는, <strong>일종의 on-demand function</strong> 정도로 생각해볼 수 있겠습니다. 다음의 예시를 보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">hello_twice</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span> (<span class="string">&#x27;Gonna say hello&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span> (<span class="string">&#x27;Gonna say hello again&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="string">&#x27;Hello again!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = hello_twice()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line">Gonna say hello</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line">Gonna say hello again</span><br><span class="line">Hello again!</span><br></pre></td></tr></table></figure><p>위와 같이 함수를 정의할 경우, CPython 컴파일러가 함수 내 <code>yield</code> 키워드를 발견합니다. 그리고, 해당 함수를 generator function으로 처리합니다.</p><p>위의 7번 라인과 같이, generator 함수가 호출되면 <strong>generator object</strong>가 생성됩니다. 8번 라인에서 <code>next(gen)</code>을 실행하면, <code>hello_twice</code>의 3번 라인까지 실행이 됩니다. 실행 도중 <code>yield</code> 키워드를 만났을 경우, 해당 함수의 실행은 일시적으로 보류된 후 값을 return 합니다. 다시 <code>next(gen)</code>을 실행할 경우 (라인 12), 일시 보류되었던 함수의 진행이, 다음 <code>yield</code>문을 만날때까지 계속됩니다. (라인 4~5) 이 과정이 함수의 끝에 도달할 때 까지 반복됩니다.</p><p><strong>Python의 stack frame은 (이름과 다르게) 메모리의 stack 영역에 올라가는 것이 아니라, heap 영역에 할당됩니다.</strong> 이러한 Python의 특징 덕분에, generator가 실행을 일시정지하고 값을 return할 때에 stack frame을 유지할 수 있습니다. 함수가 <code>yield</code>를 만나는 순간, 해당 stack frame과 코드를 어디서부터 재개할지에 대한 정보(last instruction pointer)를 보관하는 것입니다. <em>(Syed Komail Abbas)</em></p><h1 id="3-Coroutine"><a href="#3-Coroutine" class="headerlink" title="3. Coroutine"></a>3. Coroutine</h1><p>일단, ‘Coroutine’이라는 용어가 Python-specific keyword가 아니라는 사실을 인지할 필요가 있을 것 같습니다.</p><blockquote><p><strong>Coroutines</strong> are computer-program components that generalize subroutines for <strong>non-preemptive multitasking</strong>, by allowing <strong>multiple entry points for suspending and resuming execution</strong> at certain locations.</p><footer><strong>wikipedia</strong><cite><a href="https://en.wikipedia.org/wiki/Coroutine">Coroutine</a></cite></footer></blockquote><p>따라서, 질문을 “Python의 coroutine은 무엇인가?”로 잡는 것 보다는, <strong>“Python에서는 coroutine을 어떻게 구현하였나?”</strong> 로 생각하는 쪽이 혼선을 줄이는 방향이라고 생각합니다.</p><h2 id="3-1-Generator-based-‘Coroutine’"><a href="#3-1-Generator-based-‘Coroutine’" class="headerlink" title="3-1. Generator based ‘Coroutine’"></a>3-1. Generator based ‘Coroutine’</h2><p>Python이 가지고 있는 generator를 이용한다면, coroutine을 구현할 수 있어 보입니다. 함수 실행을 일시정지하거나 재개할 수 있는 entry point들이 존재한다는 점과, 그 때마다 값을 yield 할 수 있는 generator의 성질을 잘 이용하는 것이지요.</p><p>Python generator와 관련한 두가지 기능을 더 살펴봅시다. 하나는 <strong>yield되어 실행이 일시정지 되어있는 generator에게 값을 전달하는 기능</strong>입니다. 아래의 예시를 보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">echo_me</span>():</span><br><span class="line"><span class="meta">... </span>  msg_first = <span class="keyword">yield</span> <span class="string">&#x27;Ready to echo&#x27;</span></span><br><span class="line"><span class="meta">... </span>  msg_second = <span class="keyword">yield</span> msg_first</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> msg_second</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = echo_me()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line">Ready to echo</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(gen.send(<span class="string">&#x27;Hello&#x27;</span>))</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(gen.send(<span class="string">&#x27;There!&#x27;</span>))</span><br><span class="line">There!</span><br></pre></td></tr></table></figure><p><code>gen.send(&#39;Hello&#39;)</code>로 인해 generator의 실행이 재개 될 경우, <code>yield msg_first</code> 신택스 자체가 <code>&#39;Hello&#39;</code>로 처리됩니다. 이처럼, 실행이 멈춰있는 generator object의 <code>send</code> method를 호출함으로써, generator에게 데이터를 전달할 수 있습니다.</p><p>다른 하나는, <strong>generator에서 다른 generator를 yield하는 기능</strong>입니다. 이는 <a href="https://www.python.org/dev/peps/pep-0380/" title="" target="">PEP380 (Syntax for Delegating to a Subgenerator)</a>에 명시되어있습니다. 아래의 예시를 보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="string">&#x27;INNER&#x27;</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="string">&#x27;GENERATOR&#x27;</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="string">&#x27;YEAH!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="string">&#x27;Get ready for ...&#x27;</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="keyword">from</span> inner()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = outer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line">Get ready <span class="keyword">for</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(gen), <span class="built_in">next</span>(gen), <span class="built_in">next</span>(gen))</span><br><span class="line">INNER GENERATOR YEAH!</span><br></pre></td></tr></table></figure><p>라인 8과 같이 <code>yield from</code> 키워드를 사용하여 generator 내부에서도 다른 generator를 생성하여 yield를 사용할 수 있습니다. 즉, <code>yield from inner()</code>는 <code>for x from inner(): yield x</code>와 같은 역할을 하는 셈입니다. PEP380에 따르면, 이 신택스는 Python 3.3부터 추가되었다고 합니다. (따라서, Python 2.7에서 위의 예시를 실행하면 <code>yield from</code> 신택스를 이해하지 못하고 에러가 발생합니다.)</p><p>위에서 정의된 <code>echo_me</code>와 <code>inner</code>, <code>outer</code>는 일종의 coroutine입니다. (실행을 일시정지하고 재개할 수 있는 entry points들이 존재하기 때문입니다.) Generator를 이용하여 만들었으므로, ‘generator based coroutine’라고 생각할 수 있겠습니다. (여기까지는 generator와 coroutine이라는 용어의 구분이 명확하지 않습니다.)</p><p>이러한 generator based coroutine들이 값을 yield 할 경우, 항상 자신의 caller에게로 실행의 순서가 넘어가게 됩니다. 이러한 coroutine을 <strong>‘Asymmetric coroutine’</strong> 이라고 부르기도 합니다. 이와 구분되는 개념인 ‘Symmetric coroutine’의 경우에는 하나의 coroutine에서 값을 yield할 때, 다른 coroutine에게 실행 순서를 넘겨줄 수 있는 통제권을 가지고 있습니다. 무조건 자신의 caller에게 실행 순서를 넘겨주어야 하는 asymmetric coroutine과는 다르죠. <em>(Moura)</em></p><h2 id="3-2-asyncio-Module"><a href="#3-2-asyncio-Module" class="headerlink" title="3-2. asyncio Module"></a>3-2. asyncio Module</h2><p>무조건 caller와만 상호작용하는 반쪽짜리 coroutine이라니…. 만약 caller가 이러한 asymmetric coroutine들을 유기적으로 엮어주는 역할을 해준다면 (예를 들면 하나의 coroutine이 suspend 되었을 때 다른 coroutine을 실행시켜주는 역할을 해준다면), 전체적으로 보았을 때 각각의 coroutine들이 서로에게 실행 순서를 넘겨주는 것 처럼 보일 수 있겠습니다.</p><p><strong>asyncio</strong> 모듈이 이러한 역할을 해줍니다. 아래의 예시를 보겠습니다. <a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" title="" target="">asyncio docs의 예시</a> 중 하나를 참고하였습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@asyncio.coroutine</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">echo_twice</span>(<span class="params">msg</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(msg)</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop = asyncio.get_event_loop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.ensure_future(echo_twice(<span class="string">&#x27;Hello&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.ensure_future(echo_twice(<span class="string">&#x27;There&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.run_forever()</span><br><span class="line">Hello</span><br><span class="line">There</span><br><span class="line"><span class="comment"># 주춤...</span></span><br><span class="line">Hello</span><br><span class="line">There</span><br></pre></td></tr></table></figure><p><code>asyncio.coroutine</code> 데코레이터를 통해 <code>echo_twice</code> 함수를 coroutine으로 정의합니다. <code>asyncio.ensure_future(...)</code>를 통해, 실행할 coroutine을 생성합니다. <code>asyncio.get_event_loop()</code>로 받은 event loop의 <code>run_forever</code>를 실행함으로써 coroutine들을 실행합니다.</p><p>출력된 메시지를 확인해보면, 두 개의 coroutine이 동시에 진행된 것을 확인할 수 있습니다. <code>echo_twice</code> coroutine 실행 중 라인 5에 다다르면 <code>asyncio.sleep(1)</code>이 1초 뒤에 실행이 완료되는 (1초 뒤에 yield할 수 있는) coroutine을 생성합니다. 이 coroutine을 <code>yield from</code>하게 되면 event loop에게로 통제권이 넘어가고, event loop에 의해서 다른 coroutine이 실행됩니다. <em>(Mansnun)</em></p><p>이러한 방법을 통해, 여러 coroutine들이 동시에 실행될 수 있습니다. 여기서 말하는 ‘동시에’ 실행된다는 말은 parallelly가 아니라 concurrently를 의미합니다. <strong>Event loop은 single thread이므로 한번에 실행 되는 coroutine은 하나입니다.</strong> 여러 coroutine들이 하나의 thread를 타이밍 좋게 나누어 가지는 셈입니다. <em>(Masnun)</em> Concurrency에 관한 이야기와 <code>asyncio</code>에 관한 조금 더 디테일한 설명은 뒤에서 다시 하겠습니다.</p><h2 id="3-3-Native-Coroutine"><a href="#3-3-Native-Coroutine" class="headerlink" title="3-3. Native Coroutine"></a>3-3. Native Coroutine</h2><p>Python 3.5부터 새로운 신택스인 <strong><code>async</code></strong> 와 <strong><code>await</code></strong> 가 등장합니다. (<a href="https://www.python.org/dev/peps/pep-0492/" title="" target="">PEP492</a>) 이를 이용하면 위에서 선언한 <code>echo_twice</code>를 아래와 같이 다시 정의할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">echo_twice</span>(<span class="params">msg</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(msg)</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop = asyncio.get_event_loop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.ensure_future(echo_twice(<span class="string">&#x27;Hello&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.ensure_future(echo_twice(<span class="string">&#x27;There&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.run_forever()</span><br><span class="line">Hello</span><br><span class="line">There</span><br><span class="line"><span class="comment"># 주춤...</span></span><br><span class="line">Hello</span><br><span class="line">There</span><br></pre></td></tr></table></figure><p><code> @asyncio.coroutine</code> 데코레이터 대신 <code>async</code> 키워드를, <code>yield from</code> 키워드 대신 <code>await</code> 키워드를 사용했습니다. Python의 신택스만을 이용하여 정의한 coroutine이니, 이를 <strong>‘Native Coroutine’</strong> 이라고 불러도 괜찮겠습니다. <em>(Masnun)</em> 실행 도중 라인 4의 <code>await asyncio.sleep(1)</code>에 다다르면, <code>echo_twice</code> 함수는 event loop에게 컨트롤을 넘겨줍니다.<br>이 때, generator based coroutine에서 사용되는 신택스와 native coroutine에서 사용되는 신택스는 혼용될 수 없습니다. 따라서, 아래와 같은 코드는 허용되지 않습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@asyncio.coroutine</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">this_is_nono</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span></span><br><span class="line">SyntaxError: <span class="string">&#x27;await&#x27;</span> outside <span class="keyword">async</span> function</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">this_is_nono</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span></span><br><span class="line">SyntaxError: <span class="string">&#x27;yield from&#x27;</span> inside <span class="keyword">async</span> function</span><br></pre></td></tr></table></figure><h1 id="4-Concurrency와-Parallelism"><a href="#4-Concurrency와-Parallelism" class="headerlink" title="4. Concurrency와 Parallelism"></a>4. Concurrency와 Parallelism</h1><p>CPython의 메모리 관리는 thread-safe하지 않습니다. 따라서 GIL(Global Interpreter Lock)이라 불리는 mutex를 사용하여 여러 쓰레드가 동시에 Python 코드를 실행하지 못하도록 보호합니다. <em>(ThomasWouters)</em></p><p>여기서 머리가 복잡해졌습니다. 그럼 위에서 말했던 동시에 실행되는 coroutine은 어떻게 ‘동시에’ 돌아갈 수 있는 것일까요? 이를 잘 이해하기 위해서는 concurrency와 parallelism을 구분하여 정의내릴 필요가 있습니다.</p><blockquote><p><strong>Concurrency</strong> is about <em>dealing with lots of things at once</em><br><strong>Parallelism</strong> is about <em>doing lots of things at once</em></p><footer><strong>Skrew Everything</strong><cite><a href="https://medium.com/from-the-scratch/dont-be-confused-between-concurrency-and-parallelism-eac8e703943a">Don't be confused between Concurrency and Parallelism</a></cite></footer></blockquote><p>두 용어는 다른 차원의 개념입니다. <strong>Parallelism</strong>은 하나의 작업이 여러개의 작은 작업들로 나뉘어져 물리적으로 동시에 진행되는 것을 말합니다. 여러개의 CPU가 동시에 돌아가는 것을 생각하면 되겠습니다. 반면, <strong>Concurrency</strong>는 여러 작업들이 같은 순간에 (<strong>physically or logically</strong>) 처리되고 있는 상태입니다.</p><p>이 정의를 통해 알 수 있는 사실이 몇 가지 있습니다.</p><ol><li>Single Thread 환경에서도 concurrent한 작업을 수행할 수 있다. (CPU time-slicing 혹은 Application level의 scheduling을 활용)</li><li>Parallel한 작업은 Concurrent하다. 그 반대는 항상 성립하지 않는다. <em>(Skrew Everything)</em></li></ol><p><strong>Python의 coroutine들은 concurrent하게 실행됩니다. Parallel하게 돌아가는 것이 아닙니다.</strong> 앞서 이야기 했듯이, Python은 GIL로 인하여 한번에 하나의 thread만 실행이 됩니다. 따라서, 위에서 이야기 했던 asynchronous한 coroutine들은 ‘One process, One thread’ 환경에서 concurrent하게 돌아가는 것입니다. 아래는 <a href="https://medium.com/from-the-scratch/dont-be-confused-between-concurrency-and-parallelism-eac8e703943a" title="" target="">Skrew Everthing님의 포스트</a>에 삽입된 Parallelism과 Concurrency without Parallelism을 시각화한 그림입니다. Python의 GIL을 고려하였을 때, 그림의 아랫부분에 있는 <em>Concurrency without Parallelism</em>이 Python에서의 coroutine들의 동작 형태와 유사하다고 볼 수 있습니다.</p><img src="/images/2019-02-parallelism_concurrency.png" class="" width="500" title="Parallelism &amp; Concurrency"><p>그러므로, <strong>“하나의 작업을 여러개의 coroutine으로 나누어 실행 할 경우 작업이 빨라진다”라는 statement는 항상 옳지 않습니다.</strong> ‘One process, One thread’ 환경에서 돌아가기 때문에, <del>coroutine을 context switching하는 cost로 인하여</del> coroutine 스케쥴링 오버헤드로 인하여 경우에 따라서는 performance가 더 나빠질 가능성도 있습니다.</p><hr><h1 id="5-More-about-async-await-and-asyncio"><a href="#5-More-about-async-await-and-asyncio" class="headerlink" title="5. More about async, await and asyncio"></a>5. More about <code>async</code>, <code>await</code> and <code>asyncio</code></h1><h2 id="Awaitable-Objects"><a href="#Awaitable-Objects" class="headerlink" title="Awaitable Objects"></a>Awaitable Objects</h2><p><strong><code>__await__()</code> method가 구현되어 있는 object</strong>를 awaitable object라고 합니다. (<a href="https://docs.python.org/3/reference/datamodel.html#coroutines">Python Docs</a>) 이름 그대로, <code>await</code> 될 수 있는 object를 의미합니다. <strong>Coroutines</strong>, <strong>Tasks</strong>, <strong>Futures</strong>가 awaitable object에 속합니다.</p><p><strong>Coroutines</strong><br>앞서 설명한 coroutine들은 awaitable object입니다. 따라서, 다른 coroutine에서 <code>await</code> 될 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">coro</span>():</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello from coro!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_coroutines</span>():</span><br><span class="line">  coro() <span class="comment"># Coroutine object입니다. 하지만 await 되지 않았으므로 실행되지는 않습니다.</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">await</span> coro()) <span class="comment"># 이 경우, `await coro()` 가 인사를 합니다.</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main_coroutines())</span><br></pre></td></tr></table></figure><p><strong>Futures</strong><br>Future는 비동기 연산의 결과물을 대신하는 low-level awaitable object입니다. <em>(A Future is a special low-level awaitable object that represents an eventual result of an asynchronous operation. &#x2F; Represents the result of an asynchronous computation.)</em><br>Future object가 <code>await</code>될 경우, 다른 곳에서 resolve 되기 전 까지 해당 coroutine이 기다리게 됩니다. <strong>일반적인 경우, application level 코드에서 Future object를 생성 할 필요는 없습니다.</strong></p><p><strong>Tasks</strong><br>Task는 coroutine을 concurrent하게 실행하기 위하여 schedule을 해 놓은 object입니다. <code>asyncio.create_task()</code> 함수 등을 이용하여 coroutine을 Task로 wrapping 할 경우, 해당 coroutine은 자동적으로 schedule 되어서 실행 가능한 상태가 됩니다. 따라서, 위의 <code>main_coroutines()</code>에서는 <code>main_coroutine()</code>과 <code>coro()</code>가 concurrent하게 돌아가지 않지만, 아래의 <code>main_tasks()</code>에서는 <code>main_tasks()</code>와 <code>coro()</code>가 concurrent하게 실행될 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">coro</span>():</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello from coro!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_tasks</span>():</span><br><span class="line">  task = asyncio.create_task(coro()) <span class="comment"># `coro()` coroutine과 `main_tasks()` coroutine이</span></span><br><span class="line">                                     <span class="comment"># concurrent하게 돌아갈 수 있도록 scheduling 합니다</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">await</span> task) <span class="comment"># `await task` 가 인사를 합니다.</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main_tasks())</span><br></pre></td></tr></table></figure><h2 id="asyncio-module"><a href="#asyncio-module" class="headerlink" title="asyncio module"></a><code>asyncio</code> module</h2><p><code>asyncio</code>의 method 중 핵심적인 몇 가지를 정리해보면 아래와 같습니다.</p><h3 id="asyncio-run-coro-debug-False"><a href="#asyncio-run-coro-debug-False" class="headerlink" title="asyncio.run(coro, *, debug=False)"></a><code>asyncio.run(coro, *, debug=False)</code></h3><p>전달 된 coroutine을 실행하고, asyncio의 event loop를 관리합니다. 같은 thread에서 다른 asyncio event loop가 실행중일 경우에는 실행할 수 없습니다.<br><em>Python 3.7에서 새로 추가되었습니다.</em></p><h3 id="asyncio-create-task-coro"><a href="#asyncio-create-task-coro" class="headerlink" title="asyncio.create_task(coro)"></a><code>asyncio.create_task(coro)</code></h3><p>전달 된 coroutine을 wrapping하여 Task object를 만들고 schedule 합니다.<br><em>Python 3.7에서 새로 추가되었습니다.</em> 이전 Python에서는 <code>asyncio.ensure_future()</code>를 사용합니다.</p><h3 id="asyncio-sleep-delay-result-None-loop-None"><a href="#asyncio-sleep-delay-result-None-loop-None" class="headerlink" title="asyncio.sleep(delay, result=None, loop=None)"></a><code>asyncio.sleep(delay, result=None, loop=None)</code></h3><p><code>delay</code>초 동안 대기합니다. <code>result</code>가 주어진 경우, sleep이 완료된 후 해당 값을 caller에게 리턴합니다.<br><code>sleep()</code> 함수는 현재 task를 suspend 시키므로, 이 시점에 다른 task가 실행될 수 있습니다.</p><h3 id="asyncio-gather-aws-loop-None-return-exceptions-None"><a href="#asyncio-gather-aws-loop-None-return-exceptions-None" class="headerlink" title="asyncio.gather(*aws, loop=None, return_exceptions=None)"></a><code>asyncio.gather(*aws, loop=None, return_exceptions=None)</code></h3><p>주어진 awaitable objects들을 concurrent하게 실행합니다. 주어진 awaitable object 중 coroutine이 있으면, 자동으로 Task로 schedule 됩니다.<br>모든 awaitable들이 정상적으로 끝나면, 각 awaitable의 return value의 list가 return 됩니다. 순서는 <code>aws</code>의 순서와 동일합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">whoami_after_sleep</span>(<span class="params">name, t</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&#x27;I am <span class="subst">&#123;name&#125;</span> and gonna sleep for <span class="subst">&#123;t&#125;</span> seconds.&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&#x27;I am <span class="subst">&#123;name&#125;</span>. I slept for <span class="subst">&#123;t&#125;</span> seconds.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&#x27;result&#x27;</span>, name, t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">    whoami_after_sleep(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    whoami_after_sleep(<span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    whoami_after_sleep(<span class="string">&#x27;C&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># I am A and gonna sleep for 1 seconds.</span></span><br><span class="line"><span class="comment"># I am B and gonna sleep for 2 seconds.</span></span><br><span class="line"><span class="comment"># I am C and gonna sleep for 3 seconds.</span></span><br><span class="line"><span class="comment"># I am A. I slept for 1 seconds.</span></span><br><span class="line"><span class="comment"># I am B. I slept for 2 seconds.</span></span><br><span class="line"><span class="comment"># I am C. I slept for 3 seconds.</span></span><br></pre></td></tr></table></figure><h3 id="asyncio-wait-for-aw-timeout-loop-None"><a href="#asyncio-wait-for-aw-timeout-loop-None" class="headerlink" title="asyncio.wait_for(aw, timeout, *, loop=None)"></a><code>asyncio.wait_for(aw, timeout, *, loop=None)</code></h3><p>주어진 awaitable을 <code>timeout</code>초 동안 기다립니다. <code>aw</code>가 coroutine일 경우, 자동으로 Task로 schedule 됩니다.<br>해당 시간이 지나면, <code>asyncio.TimeoutError</code>가 발생합니다.</p><p>…</p><p>추가적인 설명은 <a href="https://docs.python.org/3/library/asyncio-task.html">Python Doc</a>을 참조하면 되겠습니다.</p><h2 id="Using-asyncio-based-module-aiohttp"><a href="#Using-asyncio-based-module-aiohttp" class="headerlink" title="Using asyncio based module : aiohttp"></a>Using <code>asyncio</code> based module : <code>aiohttp</code></h2><p><strong>aiohttp</strong>는 asyncio를 활용한 HTTP 클라이언트&#x2F;서버 모듈입니다. 이 모듈과 위의 내용들을 바탕으로 다수의 웹사이트를 불러오는 asynchronous를 만들어보면 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">url</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;start fetching&#x27;</span>, url)</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> res:</span><br><span class="line">      <span class="keyword">assert</span> res.status == <span class="number">200</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> res.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="keyword">await</span> asyncio.gather(*[fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.perf_counter()</span><br><span class="line">asyncio.run(main())</span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Time Elapsed : &#123;&#125; sec&#x27;</span>.<span class="built_in">format</span>(end-start)) <span class="comment"># 1.61 sec</span></span><br></pre></td></tr></table></figure><p>이와 같은 동작을 하는 synchronous한 스크립트는 시간이 얼마나 걸릴까요? 아래와 같이 간단한 테스트를 해보았습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="keyword">with</span> requests.Session() <span class="keyword">as</span> client:</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">      res = client.get(url)</span><br><span class="line">      <span class="keyword">assert</span> res.status_code == <span class="number">200</span></span><br><span class="line">      <span class="built_in">print</span>(res.status_code)</span><br><span class="line"></span><br><span class="line">start = time.perf_counter()</span><br><span class="line">main()</span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Time Elapsed : &#123;&#125; sec&#x27;</span>.<span class="built_in">format</span>(end-start)) <span class="comment"># 10.41 sec</span></span><br></pre></td></tr></table></figure><p>잘 짜여진 테스트는 아니지만, 10.41초에서 1.61초로 소요 시간이 크게 줄어들었음을 확인할 수 있습니다. 작업의 I&#x2F;O 대기시간이 길어질수록 이러한 접근 방법은 더욱 더 효과적입니다.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-안녕-비동기&quot;&gt;&lt;a href=&quot;#0-안녕-비동기&quot; class=&quot;headerlink&quot; title=&quot;0. 안녕, 비동기!&quot;&gt;&lt;/a&gt;0. 안녕, 비동기!&lt;/h1&gt;&lt;p&gt;Python으로 동시다발적 HTTP 요청을 보내는 작업을 해야할 필요가 생겼습니다. Python 3에서 asynchronous한 작업을 처리하기가 수월해졌다는 이야기를 어디서 들은 것 같아서 구글링을 간단히 해봤습니다…만 내용들이 이해하기가 쉽지 않았습니다. 이와 관련된 수 많은 용어들의 정의와 그 범위가 사람들마다 미묘하게 달랐기 때문입니다. 뿐만 아니라, ‘asynchronous’라는 용어 자체를 듣기만 해도 뭔가 어렵고 복잡하고 막연하게 두려운 느낌도 듭니다.&lt;/p&gt;
&lt;img src=&quot;/images/2019-02-why_so_async.png&quot; class=&quot;&quot; width=&quot;500&quot; title=&quot;Async Everywhere&quot;&gt;

&lt;p&gt;하루 날을 잡고 asynchronous python과 관련된 자료들을 왕창 읽어보았습니다. 이 글은 키워드 &lt;strong&gt;generator, coroutine, asyncio&lt;/strong&gt;와 신택스 &lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;, &lt;code&gt;yield from&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt;, &lt;code&gt;await&lt;/code&gt;&lt;/strong&gt; 에 대한 이해가 없던 제가, 나름대로 이해를 하는 과정을 기록한 것입니다. &lt;strong&gt;혹시나 제가 잘못 이해하고 있는 부분이 있으면 말씀해주시면 감사하겠습니다&lt;/strong&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hwangheek.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://hwangheek.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
